\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{url}
\usepackage{natbib}
\usepackage{datetime}
\usepackage{graphicx}
\usepackage{comment}

%include polycode.fmt
%include play.fmt

% general stuff
\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\C}[1]{\textsf{#1}}
\newcommand{\tup}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\mtxt}[1]{\textsf{#1}}

\newcommand{\pic}[1]{\includegraphics[scale=0.55]{#1.eps}}

% examples
\newcounter{exmp}
\setcounter{exmp}{1}
\newcommand{\yesexample}{\subsubsection*{Example \arabic{exmp}}\addtocounter{exmp}{1}}
\newcommand{\noexample}{\hfill$\Box$}

\newcommand{\todo}[1]{\textbf{\textsc{Todo:} #1}}

% code blocks
\newenvironment{code}{\begin{alltt}\small}{\end{alltt}}
\newenvironment{codepage}
    {\begin{minipage}[h]{\textwidth}\begin{code}}
    {\end{code}\end{minipage}}

\newenvironment{example}{\yesexample}{\noexample}

\newcommand{\K}{\ensuremath{^\ast}} % kleene star
\newcommand{\D}{\ensuremath{\cdot}} % central dot

\renewcommand{\c}[3]{\tup{\T{#1},\T{#2},\T{\{#3\}}}}
\newcommand{\cc}[2]{\c{#1}{$\lambda$}{#2}}

\newcommand{\s}[1]{\ensuremath{_{\tt #1}}} % subscript, in tt font
\newcommand{\g}[1]{\{#1\}} % group, put { } round it
\newcommand{\U}{\textunderscore}
\newcommand{\vecto}[1]{\overrightarrow{#1\;}}
\newcommand{\gap}{\;\;}
\newcommand{\dom}{\text{dom}}


\begin{document}

\conferenceinfo{Haskell Workshop '07}{date, City.} %
\copyrightyear{2007} %
\copyrightdata{[to be supplied]}

\titlebanner{\today{} - \currenttime{}}        % These are ignored unless
\preprintfooter{}   % 'preprint' option specified.

\title{Scrap Your Scary Types}
\subtitle{Uniform Boilerplate with Lists}

\authorinfo{Neil Mitchell}
           {York}
           {http://www.cs.york.ac.uk/$\sim$ndm/}
\authorinfo{Colin Runciman}
           {York}
           {http://www.cs.york.ac.uk/$\sim$colin/}

\maketitle

\begin{abstract}
Generic traversals and queries are often referred to as boilerplate code -- they remain relatively similar as the action performed by the code changes, and can often outnumber the actual intent of the code in terms of lines. While other generic traversal schemes have shown how powerful new features can be added to compilers, and how the type system can be manipulated into accepting these operations, this paper focuses on a conceptually simpler generic concept. The |Play| class is introduced, which abstracts over common traversals and queries in a simple manner.
\end{abstract}

\section{Introduction}

Generic programming is not a new problem, lots of solutions have been proposed. Let us take a simple example:

\begin{code}
data Expr  =  Val  Int         -- a literal value
           |  Var  String      -- a variable
           |  Neg  Expr        -- negation
           |  Add  Expr  Expr  -- addition
           |  Sub  Expr  Expr  -- subtraction
           |  Mul  Expr  Expr  -- multiplication
           |  Div  Expr  Expr  -- division
\end{code}

This is a small expression language for integer expressions, which permits free variables. To evaluate an expression an initial environment must be supplied mapping the required variables to values. A precondition on this environment is that every variable present in the expression must have a corresponding entry in the environment. This naturally leads to the requirement to specify a function which returns a list of all the variables:

\begin{code}
variables :: Expr -> [String]
variables (Var  x    ) = [x]
variables (Val  x    ) = []
variables (Neg  x    ) = variables x
variables (Add  x y  ) = variables x ++ variables y
variables (Sub  x y  ) = variables x ++ variables y
variables (Mul  x y  ) = variables x ++ variables y
variables (Div  x y  ) = variables x ++ variables y
\end{code}

This code has lots of bad properties:

\begin{itemize}
\item Adding a new constructor would require the program to change.
\item The action part is the first line, but is obscured by the rest of the code.
\item The code is repetitive, and uninteresting.
\item The volume of the code, and the repetitive nature, can lead to subtle bugs, which are easy to overlook.
\item The code is too long.
\end{itemize}

The problem is referred to as the \textit{boilerplate} problem. The boilerplate is that code which doesn't have any interesting meaning, but is there only as a tax on the programmer. Using the framework developed in this paper the above example can be rewritten as:

\begin{code}
variables :: Expr -> [String]
variables x = [y | Var y <- everything x]
\end{code}

Note that in the above example the type signature is optional, and would be inferred automatically if left absent.

\subsection{Contribution}

Of course, this isn't the first technique for removing the boilerplate, the area has been researched extensively. There are a number of novel features in our approach:

\begin{itemize}
\item We restrict ourselves to Haskell 98 where possible, introducing multi-parameter type classes only for more complex problems. Most contrasting approaches requires rank-2 types and/or GADT's.
\item We aim to make the common cases easy, and the reasonably difficult cases possible, and leave the obscure cases alone. By focusing on simplicity we bring real benefits to the programmer.
\item We require the programmer to write only one single function per type to gain access to the operations we provide.
\item We are able make use of the existing compiler support for deriving |Typeable| and |Data|, to provide automatic derivation of our class.
\item Writing additional traversals is trivial, within the reach of even casual users of the library.
\item We compare the relative performance of some traversal mechanisms, something that has been neglected in previous papers.
\item This library has already been used extensively, importantly outside the friends of the authors. Users have remarked at the ease of learning and deploying the library.
\end{itemize}

We have implemented all our code, and encourage you to download it and try it out. It can be obtained from the website at \texttt{http://www.cs.york.ac.uk/~ndm/play/}. A copy of the library has also been released, and is on Hackage.

\subsection{Goals}

The idea behind the Play class is that there exists a data structure, usually with a reasonable number of constructors, which is often transformed or analysed. The usual example of this would be a compiler, which has at its core an expression type. This can be seen as a form of generic programming.

The Play class has the following goals:

\begin{itemize}
\item Adding a new constructor should require very few changes
\item Traversals should have a minimal amount of boiler plate
\item The obvious code should ``just work''
\item Haskell 98, where possible
\item Writing new types of traverals should be easy
\item The default traversals cover most cases
\end{itemize}

The ideas behind the Play class have been used extensively, in both the Yhc compiler and the Catch tool. In Catch there are 109 traversals using the Play class (as at Nov 2006), showing that the Play class gets extensive use.

\subsection{Road map}

\S\ref{sec:combinators} introduces the traversal combinators that we propose, along with short examples. \S\ref{sec:implementation} discusses how these combinators are implemented in terms of a single primitive. \S\ref{sec:multiplay} shows how to extend this approach to more complex data types, at the cost of requiring multi-parameter type classes. \S\ref{sec:rules} lists some properties of our system, and how they can be used for optimisation. \S\ref{sec:syb} gives an implementation of our class in terms of the built in compiler support in GHC. \S\ref{sec:comparison} compares our approach with others, including the ``paradise'' benchmark. \S\ref{sec:performance} gives performance measurements of the various traversal mechanisms. \S\ref{sec:conclusion} makes concluding remarks and suggests directions for future work.


\section{Queries and Traversals}

We define various queries and traversals, using the |Expr| type defined in the introduction as an example throughout. All the traversals rely on the class |Play|, an instance of which is defined for |Expr|. This instance and definition are covered in \S\ref{sec:implementation}.

\subsection{Queries}

This library provides a single method for implementing queries, the |everything| method.

\begin{code}
everything :: Play alpha => alpha -> [alpha]
\end{code}

This function takes a data structure, and returns a list of all data structures of the appropriate type found within it. Given a tree, |everything| returns the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done above. For example:

\begin{code}
everything (Add (Neg (Var "x")) (Val 12)) =
    [Add (Neg (Var "x")) (Val 12)
    ,Neg (Var "x")
    ,Var "x"
    ,Val 12]
\end{code}

\begin{figure}
\pic{everything2}
\caption{Graphical representation of |everything|.}
\label{fig:everything}
\end{figure}

A visual representation of this example is given in Figure \ref{fig:everything}.

One use of this mechanism for querying was given in the introduction. For another example, consider the task of seeing how many divisions by the literal 0 there are -- as this will cause a runtime error.

\begin{code}
countDivZero :: Expr -> Int
countDivZero x = length [() | Div _ (Val 0) <- everything x]
\end{code}

Note that we make essential use of the feature of list comprehensions that if a pattern does not match, then no errors are returned. In other places of the Haskell language, failing to match a pattern results in a pattern-match error.

Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error. Using the \C{everything} function, all queries can be expressed very quickly and directly.

\subsection{Bottom-up Traversals}

Another common operation covered by many boilerplate removal systems is the traversal.
We define as our standard traversal a bottom up traversal.

\begin{code}
traverse :: Play alpha => (alpha -> alpha) -> alpha -> alpha
\end{code}

Take the example of removing the |Sub| constructor, a little bit of thought leads to the equation:

\begin{code}
x - y == x + (- y)
\end{code}

The desire is then to apply this rewrite at all possible places in the input expression. This can be done with:

\begin{code}
simplify x = traverse f x
    where  f (Sub x y)  = Add x (Neg y)
           f x          = x
\end{code}

This code can be read as applying the subtraction rule where you can, and where you can not, doing nothing.

Adding additional rules is trivial, let us take the example of:

\begin{code}
x + y | x == y = 2 * x
\end{code}

Now we can add this new rule into our existing traversal:

\begin{code}
simplify x = traverse f x
    where  f (Sub x y)           = Add x (Neg y)
           f (Add x y) | x == y  = Mul (Val 2) x
           f x                   = x
\end{code}

The thing to note about this example is that each rule corresponds to the natural Haskell translation of the rule. The |traverse| function manages all the required boilerplate.

So how does a bottom-up traversal work? The traversal starts by applying the function |f| to all the leaf nodes in the tree, then progressively working up to the root node. The condition on ordering is that before applying |f| to an expression, all the sub-expressions must have had |f| applied.

\subsection{Rewrite Traversals}

Following bottom-up traversals, many boilerplate schemes would define a top-down traversal. Once two traversals have been defined, how should the user pick between them? Instead we focus on modelling traversals as rewrites -- showing why providing a top-down traversal is both unnecessary, and potentially dangerous! There is no barrier to defining a bottom-up traversal in our library -- it is trivial, and we refer to such a hypothetical traversal as |traversal'|.

We define our rewrite traversal to be:

\begin{code}
rewrite :: Play alpha => (alpha -> Maybe alpha) -> alpha -> alpha
rewrite rule x = ...
\end{code}

A |rule| takes an expression of type |alpha|, and returns either |Nothing| to indicate that the rule is not applicable at this root expression, or a |Just| indicating that a modification has been performed, and that the new expression should be checked for rewrites. The postcondition for |rewrite| is that there must be no expressions where |rule| could be applied. Another way of stating this is:

\begin{code}
forall r, x `o` all (isNothing . r) (everywhere (rewrite r x))
\end{code}

It is possible to define this function in terms of |traverse|:

\begin{code}
rewrite :: Play alpha => (alpha -> Maybe alpha) -> alpha -> alpha
rewrite f = traverse g
    where g x = maybe x (rewrite f) (f x)
\end{code}

This function can be seen as trying to apply the rule everywhere in a bottom-up manner, and if at any point if makes a change, then the new tree has the rewrite applied to it. Assuming the set of rules is confluent and terminating, there will be no difference between a top-down and bottom-up application of the rules.

Obviously the disadvantage of |rewrite| is that if the rule modifies a tree only slightly, then large amounts of wasted work could be performed checking expressions repeatedly. Because of this, most programmers would rather use an explicit traversal -- namely top-down or bottom-up, and manage this rewriting themselves. But which one of top-down and bottom-up is most appropriate, and how would it be augmented to ensure |rewrite| behaviour?

\subsubsection{Rewrite as Bottom-Up}

Given a rewrite |f :: alpha -> Maybe alpha|, we can construct |f' :: alpha -> alpha| by |f' x = maybe x id x|. Now what are the preconditions on |f| such that |forall x `o` rewrite f x == traverse f' x|?

There answer is that in |f| the root matching of any equation may not overlap with any of the constructors introduced freshly on the right hand side. For example, taking the traversals from the previous section:

\begin{code}
f (Sub x y)           = Just $ Add x (Neg y)
f (Add x y) | x == y  = Just $ Mul (Val 2) x
f _                   = Nothing
\end{code}

Here |Add| occurs on the right-hand side of the first line, and on the left-hand side of the second. When applied as a single traversal, we can construct a value where the two alternatives differ:

\begin{code}
let x = Sub (Neg (Var "q")) (Var "q")

rewrite   f   x = Mul (Val 2) (Var "q")
traverse  f'  x = Add (Var "q") (Neg (Var "q"))
\end{code}

So is it possible to easily remedy this situation? The answer is yes, whenever the right-hand side introduces a new constructor, an additional onward call can be made:

\begin{code}
f (Sub x y)           = f $ Add x (f $ Neg y)
f (Add x y) | x == y  = f $ Mul (f $ Val 2) x
f x                   = x
\end{code}

This approach guarantees that the traversal is a rewrite, but in fact only one of those |f| calls is necessary, the one attached to the construction of an |Add| value.


\subsubsection{Rewrite at Top-Down}

Now we pose the same question: under what circumstances is a top-down traversal a rewrite, and what modifications can be made to ensure it becomes so?

Before we can answer this question, we must first reflect on what a top-down traversal means. The usual answer is that a modification is on the original tree, at the root. After being modified, the action is re-run upon each of the children.

A sufficient restriction to impose on |f| is that the leaves of left-hand side matches must be distinct from the constructions on the right hand side, although this condition is overly strict. To obtain the correct restriction requires a complete analysis of both the left and right sides.

Note that this restriction is neither strictly more restrictive or less restrictive than the one imposed on bottom-up traversals. \todo{Example}

In a similar manner to bottom-up traversals, we wonder if it is possible to modify |f| minimally to permit a rewrite traversal. The answer is no, consider:

\begin{code}
f (Add (Lit x) (Lit y)  ) = Lit (x+y)
f (Neg (Lit x)          ) = Lit (negate x)
\end{code}

Now choose the value:

\begin{code}
let x = Add (Lit 5) (Neg (Lit 2))

rewrite f x = Lit 3
traverse' f x = Add (Lit 5) (Lit -2)
\end{code}

Now, are we able to find a simple mechanism to go back to obtaining full rewrite behaviour? No. One option is to perform the traversals on the matches of the first equation before doing the match, perhaps a |case| expression -- effectively resulting in a bottom-up traversal. The other option is do rewrite on the entire new right-hand side -- modelling the behaviour of rewrite.


\subsubsection{Summary}

As a result we consider top-down traversals to be more complex and less functional than bottom-up traversals, and we do not include them in our library. An initial version of this library included top-down traversals -- we found they were rarely the correct choice. After investigating further, we discovered that most uses of top-down traversals were to model rewrites where information was pushed down, and most of these functions were wrong in corner cases. This experience lead us to the decision that top-down traversals do not deserve library support.

We include |rewrite| but suspect that most users would be better suited with |traverse|.


\subsection{Action Traversals}

We have introduced rewrite traversals, where the intention was to apply a set of rules until a fixed point was found. The alternative is action traversals, where the order each node wants to be visited and transformed. The |descend| and |traverse| actions can be used to perform this, but a standard technique for allowing actions is to thread a monad through the actions. We do this by introducing |traverseM|, |descendM| and |rewriteM|.

Let us assume that each variable wants to be renamed so it is unique.

\begin{code}
uniqueVars :: Expr -> Expr
uniqueVars x = evalState (traverseM f x) vars
    where
        vars = ['x':show i | i <- [1..]]

        f (Var i)  = do  y:ys <- get
                         put ys
                         return (Var y)
        f x        = return x
\end{code}

Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.


\subsection{Top-Down Descending}

While we have decided that top-down traversals are unnecessary for our library, we still believe that some traversals operate more naturally in a top-down manner. An extension to the top-down traversal includes one where information is pushed downwards at the same time.

Consider the addition of the constructor |Let String Expr Expr| -- binding the variable introduced. In order to determine which variables are used in an unbound manner, we need to ``remember'' which variables have been introduced as we descend. We introduced the |descend| function, taken from the Compos paper \cite{compos}.

\begin{code}
descend :: Play alpha => (alpha -> alpha) -> alpha -> alpha
\end{code}

Now we can write out function with:

\begin{code}
replaceVars :: [(String,Expr)] -> Expr -> Expr
replaceVars rep x =
    case  x of
          Let name bind x -> Let name
              (replaceVars rep bind)
              (replaceVars (filter ((/= name) . fst) rep) x
          Var x -> fromMaybe (Var x) (lookup x rep)
          _ -> descend (replaceVars rep) x
\end{code}

Note that although this function is finished, we have only specified what to do in the two interesting cases, namely |Let| and |Var|.

The |descend| function applies a function to all children of a node, then reconstructs a new result using those results. It is a useful function to have, and often is a better choice than top-down traversals, as it preserves the order you would require, but makes more things explicit.


\subsection{Folds}

Traditionally in Haskell a fold replaces each constructor with an alternative. To define a complete fold on a data type, each constructor must be represented, and there is no obvious library function to abstract over this process. A more useful fold for a library such as this would be to allow a default operation. To do this we have:

\begin{code}
fold :: Play alpha => ([r] -> t) -> (alpha -> t -> r) -> alpha -> r
\end{code}

Now lets imagine that programmers are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.

\begin{code}
depth :: Expr -> Int
depth = fold (foldr max 0) $ const (+1)
\end{code}

Our |fold| function takes two functions, one which combines a list of values representing each child, and one which generates a new value given the value for the children and this particular node. In the above example we have used |foldr max 0| to combine all the children -- |maximum| is inappropriate, as |maximum [] = {-"\bot"-}|. The second function |const (+1)| simply adds one to the previous depth.


\subsection{EverythingContext}

The final operation in the library is a curious one -- we have not seen it referenced in any other library, even in those which attempt to include all variations \cite{replib}. However, if the user requires this particular function, they really do need it -- faking it from other operations requires a lot of monadic complexity. This function was actually contributed by a user, which we feel enhances our claim that average users can construct their own operations upon our framework.

Imagine that you wish to change the value of one literal by one, either increasing or decreasing. This particular operation could be useful for mutation testing. To do this we require the function:

\begin{code}
everythingContext :: Play alpha => alpha -> [(alpha, alpha -> alpha)]
\end{code}

This function returns two lists, one of which is the list as would be returned by everything. The other is the function which would replace the hole which the given expression was removed from. It has the properties:

\begin{code}
forall x `o` everything x == map fst (everythingContext x)
forall x `o` all (== x) [b a | (a,b) <- everythingContext x]
\end{code}

Now we are in a situation to write our function:

\begin{code}
mutants :: Expr -> [Expr]
mutants x =  [gen (Val j)
             | (Val i, gen) <- everythingContext x
             , j <- [i-1, i+1]]
\end{code}


\subsection{Summary}

\begin{figure}
\begin{code}
module Data.Generics.Play where

class Play alpha where
    descend            :: (alpha -> alpha) -> alpha -> alpha
    descendM           :: Monad m => (alpha -> m alpha) -> alpha -> m alpha
    everything         :: alpha -> [alpha]
    everythingContext  :: alpha -> [(alpha, alpha -> alpha)]
    fold               :: ([r] -> t) -> (alpha -> t -> r) -> alpha -> r
    rewrite            :: (alpha -> Maybe alpha) -> alpha -> alpha
    rewriteM           :: Monad m  => (alpha -> m (Maybe alpha))
                                   -> alpha -> m alpha
    traverse           :: (alpha -> alpha) -> alpha -> alpha
    traverseM          :: Monad m => (alpha -> m alpha) -> alpha -> m alpha
\end{code}
\caption{All |Play| methods.}
\label{fig:play}
\end{figure}

We present all our methods in Figure \ref{fig:play}, including several monadic variants. We consider these methods encapsulate most of the common operations. In our experience, the most common operations are |everything| and |traverse|, with |traverseM| being the next most common.


\section{Implementing Play}

Requiring each class to implement nine separate methods would be overly arduous. Instead we implement all of these operations on top of just a single method:

\begin{code}
replaceChildren :: Play alpha => alpha -> ([alpha], [alpha] -> alpha)
replaceChildren x = (children,generate)
\end{code}

Given |x|, the function |replaceChildren| will return a tuple comprising of: |children| - all the children of the same type; |generate| - a function to generate a new value with a different set of children. The caller of |generate| must ensure that the length of the list given to it is the same as the length of |children|. The implementor must ensure two conditions:

\begin{code}
forall x `o` x == generate children
    where (children,generate) = replaceChildren x
\end{code}

Firstly, generating a new value using the existing children must give the same value back.

\begin{code}
forall x ys `o`  length ys == length children =>
                 fst (replaceChildren (generate ys)) == ys
    where (children,generate) = replaceChildren
\end{code}

Secondly, after inserting a new set of children, getting those children must return them back.


\subsection{Operations in terms of |replaceChildren|}

Defining operations in terms of |replaceChildren| is easy, we implement the four most common as an example. None is more than a handful of lines long, and none has great deep complexity:

\begin{code}
everything :: Play alpha => alpha -> [alpha]
everything x = x : concatMap everything $ getChildren x

traverse :: Play on => (on -> on) -> on -> on
traverse f x = f $ generate $ map (traverse f) current
    where (current, generate) = replaceChildren x

traverseM :: (Monad m, Play on) => (on -> m on) -> on -> m on
traverseM f x = mapM (traverseM f) current >>= f . generate
    where (current, generate) = replaceChildren x

descend :: Play on => (on -> on) -> on -> on
descend f x = generate $ map f current
    where (current, generate) = replaceChildren x
\end{code}

The common pattern is to call replace children, then perform some action on the current children, before combining them back. The |everything| function may be optimised further -- something we return to in \S0.

\subsection{Writing |Play| instances}

While in some generics libraries it is trivial to write the instances, in our case it is more challenging. This is not of a big concern, we have developed automated approaches to deriving these libraries within the \textsc{Derive} tool.

\begin{figure}
\begin{code}
instance Play Expr where
    replaceChildren (Neg  a    )  = ([a]    , \[a']     -> Neg  a'     )
    replaceChildren (Add  a b  )  = ([a,b]  , \[a',b']  -> Add  a' b'  )
    replaceChildren (Sub  a b  )  = ([a,b]  , \[a',b']  -> Sub  a' b'  )
    replaceChildren (Mul  a b  )  = ([a,b]  , \[a',b']  -> Mul  a' b'  )
    replaceChildren (Div  a b  )  = ([a,b]  , \[a',b']  -> Div  a' b'  )
    replaceChildren _             = ([]     , \[]       -> x           )
\end{code}
\caption{Instance of |Play| for |Expr|.}
\label{fig:play_expr}
\end{figure}

We construct a |Play| instance for the |Expr| type in Figure \ref{fig:play_expr}. The pattern of the instance can be seen easily. The default clause has no children of type |Expr|, meaning the leaves have been reached. Some simple combinators are provided to allow these derivations to be written more compactly, but they are not introduced here as they only serve to complicate the story.


\subsection{Derivation Rules}

\todo{Move to explicit sum and product rules}

The distinguishing feature of our libraries is that the children are defined in terms of their type -- while this makes the traversals and queries simpler, it does mean that the definition is dependent on the types of the constructors. We can model the type of an operation with the following construction:

\begin{code}
data Type  =  None
           |  Target
           |  List  Type
           |  Pair  Type Type
\end{code}

While arbitrary sized tuples are supported, along with the |Maybe| type, their rules are no more complex and fit easily into the framework we develop. With this, we define the |<|| `o` ||>| operation, using this we can write a |getChildren| clause as:

\begin{code}
getChildren (C (x1::t1) .. (xn::tn))
    = concat [ <| t1 |> x1, .. , <| tn |> xn]

<| Type         |> :: Type -> [alpha]
<| None         |> = const []
<| Target       |> = (:[])
<| Pair  t1 t2  |> = \(x1,x2) -> <| t1 |> x1 ++ <| t2 |> x2
<| List  t1     |> = concatMap \? <| t1 |>
\end{code}

Having implemented |getChildren|, we can imagine that it may be natural to implement |setChildren|, which could be combined to create |replaceChildren|. For efficiency reasons these two operations are combined into one, requiring only one examination of each constructor, but we present these two methods separately.

\begin{code}
type Cont t = [alpha] -> (t,[alpha])

setChildren (C (x1::t1) .. (xn::tn))
    = value' $ const' C <> <| t1 |> x1 <> .. <> <| tn |> xn

<| Type         |> :: Type -> Cont t
<| None         |> x = const' x
<| Target       |> x = id' x
<| Pair t1 t2   |> (x1,x2) = const' (,) <> <| t1 |> x1 <> <| t2 |> x2
<| List t       |> xs = list' <| t |> xs
    where
        list' fn []      = const' []
        list' fn (x:xs)  = const' (:) <> fn x <> list' fn xs


const' :: t -> Cont t
const' x ns = (x,ns)

id' :: alpha -> Cont alpha
id' x (n:ns) = (n,ns)

value' :: Cont t -> [alpha] -> t
value' c ns = fst $ c ns

(<>) :: Cont (a->b) -> Cont a -> Cont b
(<>) a b ns1 = let (a',ns2) = a ns1
                   (b',ns3) = b ns2
               in  (a' b',ns3)
\end{code}

Of course, all these tuples are very bad for the soul, and should be removed with continuation passing style:

\begin{code}
type Cont t = [alpha] -> (t -> [alpha] -> r) -> r

const' x ns c = c x ns
id' x (n:ns) c = c n ns
value' c ns = c ns const

(<>) a b ns c =  a ns $ \a' ns ->
                 b ns $ \b' ns ->
                 c (a' b') ns
\end{code}

In reality all but the |list'| function are expanded out inline.


\subsection{Using Derive}

Apply the presented derivation rules is quite time consuming, and does not produce the cleanest instances. Take for example the type:

\begin{code}
data Term  =  Name String
           |  Apply Term [Term]
\end{code}

The generated code for the instances would be:

\begin{code}
replaceChildren (Name x1) =
    (concat [const [] x1]
    ,value $ Name <> const' x1
    )

replaceChildren (Apply x1 x2) =
    (concat [(:[]) x1, concatMap (:[]) x2]
    ,value $ Apply <> id' x1 <> list' x2
    )
\end{code}

Through transformation these can be written as:

\begin{code}
replaceChildren (Name x1) =
    ([], \_ -> Name x1)

replaceChildren (Apply x1 x2) =
    (x1:x2, \(n:ns) -> Apply n ns)
\end{code}

Note that the |setChildren| in the |Apply| case changes the strictness -- but assuming the |getChildren| case has been executed first, this is still the same overall strictness.

These transformations are automatically performed by derive.

\section{Multi-type Queries and Traversals}

We have introduced |Play| which operates on values of type |Expr|. Now let us imagine that our |Expr| type is merely the expression type in a language with statements:

\begin{code}
data Stmt  =  Assign String Expr
           |  Sequence [Stmt]
           |  If Expr Stmt Stmt
           |  While Expr Stmt
\end{code}

We can define a |Play| instance for |Stmt|, and perform queries and traversals upon it. Unfortunately, if we wish to start with a |Stmt| and extract the |Expr| values from inside, this is not possible with |Play|. To allow this behaviour, we introduce the |PlayEx| class -- a multiparameter type class.

Alas |PlayEx| takes us outside the realms of Haskell 98, so after presenting |PlayEx| we give a simple encoding back into Haskell 98 in the form of |PlayOn|. While the |PlayEx| class gives greater flexibility, the |PlayOn| class is still a useful alternative when Haskell 98 compatibility is required.

\subsection{Queries}

In \S\ref{whatever} we presented a query |variables| that extracted all the variables within an |Expr|. Now using |PlayEx| we are able to generalise this query so that it operates on all structures containing |Expr| values inside:

\begin{code}
variables :: PlayEx beta Expr => beta -> [String]
variables x = [y | Var y <- everythingEx x]
\end{code}

Note that the only change to the a actual code is the addition of the |Ex| suffix to |everything|. The type signature has changed so that instead of |Expr -> [String]| we have replaced |Expr| with |PlayEx beta Expr => beta|. Another way of looking at this is instead of requiring the input to be an |Expr|, we merely require that from the input we know how to reach an |Expr|.

Other than these small changes, the query code remains much the same.

\subsection{Traversals}

\begin{code}
simplify x = traverseEx f x
    where  f (Sub x y)  = Add x (Neg y)
           f x          = x
\end{code}

In a similar manner to before, we simply add an |Ex| at the end. Nice and simple.


\section{Implementing PlayEx}


\begin{figure}
\begin{code}
class Play alpha => PlayEx beta alpha where
    replaceType :: beta -> ([alpha], [alpha] -> beta)

    getType :: beta -> [alpha]
    getType = fst . replaceType
\end{code}
\caption{|PlayEx| class.}
\label{fig:playex}
\end{figure}


The |PlayEx| class is defined in Figure \ref{fig:playex}. Consider |alpha| to be the type on which to perform operations, and |beta| to be the initial type -- which contains examples of |alpha|. The idea of the |replaceType| function is much the same as |replaceChildren|, but instead of finding then children of this node, you find the occurrences of |alpha| within |beta|.

One thing to note, when defining |PlayEx| where |alpha == beta| the program does not descend to the children, but simply returns this particular node. This ``same type'' restriction can be captured using |Typeable|. There are two separate methods for defining a |PlayEx| instance -- using only MPTC's and overlapping instances (in a safe way). One requires the use of Typeable, and a set of combinators to define classes, the other requires the use of |Data| -- and consequently rank-2 types -- but can be automatically derived by GHC.

We would also like to automatically derive |Play| from |PlayEx| where possible.

\subsection{Manual instances}

This requires |O(n^2)| but gives the highest performance. Like before these can be automatically generated, and you can move to these instances afterwards. These instances are not quite mechanical, but are certainly easier than |Play|.

\begin{code}
instance PlayOne NExpr where
    playOne x =
        case x of
            NNeg  a    -> play NNeg |* a
            NAdd  a b  -> play NAdd |* a |* b
            NSub  a b  -> play NSub |* a |* b
            NMul  a b  -> play NMul |* a |* b
            NDiv  a b  -> play NDiv |* a |* b
            _          -> play x
\end{code}

There are 5 combinators available, go through all of them.

The advantage of this is that you don't need to search into deep corners.


\subsection{In terms of |Typeable|}

Writing |PlayEx| can be done following a similar scheme to |Play|. However, the freedom to use multi-parameter type classes can give us a little more freedom. By using overlapping instances, we can use the |/\| combinator:


To define the PlayEx class, there are three combinatiors that can be used. These automate much of the definition:

\begin{code}
play :: on -> ([with],[with] -> on)
(/\) :: PlayEx item with => ([with], [with] ->
    item -> on) -> item -> ([with], [with] -> on)
(/\!) :: ([with], [with] -> item -> on) ->
    item -> ([with], [with] -> on)
\end{code}

Note, the above are presented with type signatures for completeness. They are intended to be used mechanically, without excessive thought.

To define a PlayEx instance for the Expr type introduced earlier:

\begin{code}
instance PlayEx Expr a where
    replaceChildrenEx x =
        case x of
            Val a -> play Val /\! a
            Add a b -> play Add /\ a /\ b
            Sub a b -> play Sub /\ a /\ b
            ...
            Neg a -> play Neg /\ a
\end{code}

The definition follows mechanically. The only choice a user makes is whether to use the |(/\)| operator (which recurses into the child on the right), or the |(/\!)| operator, which doesn't. For example, here we have decided not to traverse inside the Int of Val. This can be changed, and would require a PlayEx instance for Int.

If using this style of definition, a special instance must be defined for the self case:

instance PlayEx Expr Expr where
    replaceChildrenEx = playSelf

Unfortunately this requires undecidable instances. A Play instance still needs to be written for each definition.


\subsection{In terms of |Data|}

We are able to make use of the existing |Data| and |Typeable| instances provided by the SYB approach to define Play classes. To have access to all |Play| and |PlayEx| instances simply:

\begin{code}
import Data.Generics.PlayData
import Data.Generics

data Expr ... deriving (Typeable, Data)
\end{code}

The disadvantages of this are the lack of type safety - you can now do entirely meaningless operations, which the earlier definitions would have spotted as being an error. This code will also only work where Data.Generics is supported, namely GHC at the present time. The clear advantage is that there is almost no work to creating Play instances.

\begin{figure}
\begin{code}
repChildren  :: (Data alpha, Play beta, Typeable alpha, Typeable beta)
             => alpha -> ([beta],[beta] -> alpha)
repChildren item = (collect, generate)
    where
        collect = concat $ gmapQ getChildrenEx item

        generate xs = evalState (gmapM f item) xs
        f x = do  let (col,gen) = replaceChildrenEx x
                  (as,bs) <- liftM (splitAt $ length col) get
                  put bs
                  return $ gen as
\end{code}
\caption{Code for |Play| in terms of |Data|.}
\label{fig:playdata}
\end{figure}

How do we implement these classes? The fundamental operation is given in Figure \ref{fig:playdata}. The outer class uses the same method as given in the |Typeable| derivation, and if the program does need to descend, then this is done by |repChildren|. The operation to get the children can be done using |gmapQ|. The operation to replace the children is more complex, requiring a state monad to keep track of the items to insert.

This instance is not optimised for speed, in particular the |splitAt|/|length| portion will take traverse the list more than is necessary. We discuss how to come up with an optimised version in \S0.

\section{PlayOn}

After having seen the increased power available with |PlayEx|, users of Haskell 98 may be getting jealous. While the |PlayEx| strategy is ultimately the most powerful, there is a restricted solution available.

Imagine that a program mainly manipulates one type, the |Expr| type, but that this type is placed in many containers. Then in this case we can construct the |PlayExpr| type which is equivalent to |PlayEx| but with |Expr| frozen as the second argument. While is is not particularly beautiful, it does make the multi-type operations accessible to more users.

This has been used extensively in the Yhc compiler. Since the Yhc compiler does not support multi-parameter type classes, and is hoped to be bootstrapping shortly, this rules out MPTC.

\section{Properties}

This section discusses various properties that hold. Some of these could be turned into GHC rules, but this has not been done.

\subsection{General Properties}

\begin{code}
descend id == id
traverse id == id
rewrite (const Nothing) == id

descendM return == return
rewriteM (return . const Nothing) == return
traverseM return == return

fold _ const = id

everything . traverse f == map (traverse f) . everything
\end{code}

\subsection{List Properties}

A list is defined inductively as |data [alpha] = [] || alpha : [alpha]|. We can therefore define a |Play| instance as:

\begin{code}
instance Play [alpha] where
    replaceChildren []      = ([]    , const []       )
    replaceChildren (x:xs)  = ([xs]  , \[xs] -> x:xs  )
\end{code}

Now some common list operations can be represented as traversals:

\begin{code}
everything == tails
\end{code}



\section{Coding Benchmarks}

In this section we compare specific examples of operations using the |Play| framework versus other frameworks. In particular the alternatives we focus on are Scrap Your Boilerplate and Compos. We start by using the single-type examples from Compos, then move on to the multi-type traversals. We then move on to the ``Paradise Benchmark'' from SYB. In all cases the Compos, SYB and Play functions are denoted by a preceding module name qualified. In some instances, a single operate function can be written the same in both SYB and Play -- where this is possible we have done so. Where possible, type signatures have been left absent -- these are a form of boilerplate that Haskell already deals with.

We explicitly do not focus on the execution time for these operations, instead leaving this to the next section.

\subsection{Simple Examples from This Paper}

Here we simply give variations for the code shown before. Since our existing coding is so short, we have replicated it.

\subsubsection{|variables|}

\begin{code}
Play.variables x = [y | NVar y <- everything x]

SYB.variables = everything (++) ([] `mkQ` f)
    where  f (NVar y)  = [y]
           f _         = []

Comp.variables :: Expr a -> [String]
Comp.variables x = case x of
    Var y -> [y]
    _ -> composOpFold [] (++) Comp.variables x
\end{code}

In this example only Compos has been given a type signature, this is because in the other examples one can be automatically inferred -- but not for Compos. We note that list comprehensions are wonderful for queries.

\subsubsection{|zeroCount|}

\begin{code}
Play.zeroCount x = length [() | Div _ (Val 0) <- everything x]

SYB.zeroCount = SYB.everything (+) (0 `mkQ` f)
    where  f (Div _ (Val 0))  = 1
           f _                  = 0

Comp.zeroCount :: Expr a -> Int
Comp.zeroCount x = case x of
    Div y (Val 0) -> 1 + zeroCount y
    _ -> composOpFold 0 (+) zeroCount x
\end{code}

Note here that the returning of a list of |()| is not as neat as it could be. Also, note the continuation in the Compos solution -- if this was missed (which is easy) it wouldn't work. This shows that manually continuing the traversal could be dangerous in some cases.

\subsubsection{|simplify|}

\begin{code}
simp (Sub x y)           = Add x (Neg y)
simp (Add x y) | x == y  = Mul (Val 2) x
simp x                   = x

Play.simplify = traverse simp

SYB.simplify = everywhere (mkT simp)

Comp.simplify :: Expr a -> Expr a
Comp.simplify x = case x of
    Sub  a b -> Add (simplify a) (Neg (simplify b))
    Add  a b -> case  (simplify a, simplify b) of
                      (a',b')  | a' == b'   -> Mul (Val 2) a'
                               | otherwise  -> Add a' b'
    _ -> composOp simplify x
\end{code}

Note here that this situation really calls out for a bottom-up traversal, which we provide, but Compos does not.


\subsection{Multi-type Compos Examples}

\begin{figure}
\begin{code}
data Stm  =  SDecl    Typ Var
          |  SAss     Var Exp
          |  SBlock   [Stm]
          |  SReturn  Exp

data Exp  =  EStm  Stm
          |  EAdd  Exp Exp
          |  EVar  Var
          |  EInt  Int

data Var  =  V String

data Typ  =  T_int | T_float
\end{code}
\caption{Data type from Compos.}
\label{fig:compos}
\end{figure}

The types manipulated by Section 4 are given in Figure \ref{fig:compos}. The first thing done by the Compos paper is to translate this into a GADT, which destroys abstraction. If a data structure representing a program was also defined, then this would have to be merged into the single GADT. Play on the other hand accepts the definition as supplied.

We have not discussed the |warnAssign| function from this paper, as it could be implemented much more neatly as a query.

\subsubsection{The |rename| function}

\begin{code} % compos
ren (V x) = V ("_" ++ x)

Play.rename = traverseEx ren

SYB.rename = everywhere (mkT ren)

Comp.rename :: Tree c -> Tree c
Comp.rename t = case t of
    V x -> V ("_" ++ x)
    _   -> composOp rename t
\end{code}

The first thing to note is the Play function is shorter, there is only one constructor in type |Var|. In contrast Compos has merged all constructors into one GADT, and can not benefit from this. The Compos function works over all trees, including those based on |Typ|, which is meaningless, since types do not contain variables. The Play class only operates on |Exp| and |Stm| types.


\subsubsection{The |symbols| function}

\begin{code}
Play.symbols x = [(v,t) | NSDecl t v <- everythingEx x]

SYB.symbols = everything (++) ([] `mkQ` f)
    where  f (NSDecl t v)  = [(v,t)]
           f _             = []

Comp.symbols :: Tree c -> [(Tree Var, Tree Typ)]
Comp.symbols x = case x of
    SDecl typ var -> [(var,typ)]
    _ -> composOpMonoid symbols t
\end{code}

Here the Compos function does a traversal of the tree, however again the Play class simply extracts the right bits. This example is almost identical to the previous |warnAssign| using Play, however the Compos approach introduces distinctions by requiring a more ordered approach to traversal.


\subsubsection{The |constFold| function}

\begin{code}
optimise (EAdd (EInt n) (EInt m)) = EInt (n+m)
optimise x = x

Play.constFold = traverseEx optimise

SYB.constFold = everywhere (mkT optimise)

Comp.constFold :: Tree c -> Tree c
Comp.constFold e = case e of
    EAdd x y -> case  (f x, f y) of
                      (CEInt n, CEInt m) -> CEInt (n+m)
                      (x',y') -> CEAdd x' y'
    _ -> composOp constFold e
\end{code}

The constant folding operation is a bottom-up traversal, requiring sub expressions to have been replaced before they are examined. Unfortunately Compos only supports top-down traversals, requiring the user to manually do a small traversal in the middle. Play and SYB both support bottom-up traversals, so this works fine.


\subsection{The Paradise Benchmark}

\begin{figure}
\begin{code}
type Manager  = Employee
type Name     = String
type Address  = String

data Company   = C [Dept]
data Dept      = D Name Manager [Unit]
data Unit      = PU Employee | DU Dept
data Employee  = E Person Salary
data Person    = P Name Address
data Salary    = S Integer
\end{code}
\caption{Paradise Benchmark data structure.}
\label{fig:paradise}
\end{figure}

The Paradise benchmark was introduced in SYB \ref{syb}. The data type is shown in Figure \ref{fig:paradise}. The idea is that this data type represents an XML file, and a Haskell program is being written to perform various operations over it. The Compos paper includes an encoding into a GADT, with tag types for each of the different types.

We have made one alteration to the data type -- |Salary| is no longer of type |Float| but of type |Integer|. In various experiments we found that the floating point numbers could not be guaranteed to have the required accuracy -- making different operations return different results, despite being theoretically the same. This change is of no consequence to the boilerplate code -- although does remind us that storing your salary in a non-exact manner is probably not a great idea!

\subsubsection{The |increase| function}

The first function discussed in the SYB paper is |increase|. This function increases every item of type |Salary| by a given percentage. In order to fit with our modified |Salary| data type, we have chosen to increase all salaries by |k|.

\begin{code}
incS :: Integer -> Salary -> Salary
incS k (S s) = S (s + k)

Play.increase k = traverseEx (incS k)

SYB.increase k = everywhere (mkT (incS k))

Comp.increase :: Integer -> Tree c -> Tree c
Comp.increase k c = case c of
    S s -> S (s + k)
    _ -> composOp (increase k) c
\end{code}

The effect of Compos to transform all constructors into the same set means that instead of just matching on |S|, all constructors must be examined.

\subsubsection{The |incrOne| function}

The |incrOne| function performs the same operation as |increase|, but only within a named department. We are able to reuse the |increase| function from the previous section in all cases.

\begin{code}
Play.incrOne n k = descendEx f
    where f x@(ND name _ _)  | name == n  = increase k x
                             | otherwise  = descend f x

SYB.incrOne n k a  | isDept n a  = increase k a
                   | otherwise   = gmapT (incrOne n k) a
    where  isDept n = False `mkQ` isDeptD n
           isDeptD n (D n2 _ _) = n == n2

Comp.incrOne :: Name -> Float -> Tree c -> Tree c
Comp.incrOne d k c = case c of
    D n _ _ | n == d -> Comp.increase k c
    _ -> composOp (incrOne d k) c
\end{code}

Here SYB has grown substantially more complex, to accommodate the invariant, requiring two different utility functions. Compos still retains the same structure as before, requiring a case to distinguish between the types of constructor. A simple |traverse| would not suffice here as if a department is contained within a department of the same name, then the employees would have their salaries increased twice.

\subsubsection{The |salaryBill| function}

The final function is one which sums all the salaries.

\begin{code}
Play.salaryBill x = sum [x | S x <- everythingEx x]

SYB.salaryBill = everything (+) (0 `mkQ` billS)
   where billS (S f) = f

Comp.salaryBill :: Tree c -> Integer
Comp.salaryBill c = case c of
    S s -> s
    _ -> composOpFold 0 (+) Comp.salaryBill c
\end{code}

Here the Play instance wins by being able to use a list comprehension to select the salary value out of a Salary object. The Play class is the only one that is able to use the standard Haskell |sum| function, not requiring an explicit fold to be performed. This solution is nice in that it is a very specification orientated view of the problem. Take all the salaries, get their value, and sum them.


\section{Implementation Speed}

Something that has been neglected in previous papers on boilerplate is the performance aspects. The first SYB paper gives the quotation ``Our benchmarks show that generic programs are reasonably efficient'', and gives a slow down of 3.5 times for the salary increase program. We choose to benchmark on all the examples shown in the previous section. Our benchmark uses the code as presented in that section. We also benchmark against a hand-coded operation with no boilerplate. The four |Play| derivations are provided by:

\begin{description}
\item[Hand Coded:] These are |Play| and |PlayEx| instances written by hand. We have chosen not to use continuation-passing to implement these instances, as it quickly becomes deeply complex. We have implemented both |getChildren| and |replaceChildren|.
\item[Manual:] These instances use the manual combinators, defined a required.
\item[Typeable:] These instances use the standard typeable combinators.
\item[Data:] These instances use the SYB |Data| instances directly.
\end{description}

In many cases there are several equivalent |Play| methods that could be used, we choose only the simplest.

First all data structures used have 100 particular values randomly generated and saved. In order to ensure a fair comparison, we define one data structure which is the same as the original, and one which is a GADT encoding. All operations take these original data structures, transform them into the appropriate structure, apply the operation and then unwrap them. We measure all results relative to the time taken for a raw transformation as 1. We compiled all programs with -O2.

The results are presented in Table n, and graphs in Figure n and m. This shows that using well tuned instances, Compos is the same speed as Play. Using Data instances, we are still able to outperform Scrap Your Boilerplate -- for whom Data instances are perfect! At first glance, these results may well seem surprising, given the intermediate list of children created and examined at each stage. We first discuss the manual Play instances, and how they are optimized -- primarily by using continuations. We then focus on our optimization of |everything|, again using continuation passing -- and additionally using some |foldr|/|build| fusion properties. Finally we turn to our |PlayData| module, and how we are able to outperform SYB using their instances underneath.

We suspect there are further places for improvement:

\begin{itemize}
\item Continuation passing style may eliminate tuple construction and consumption.
\item List fusion may be able to eliminate some of the lists in |replaceChildren|.
\end{itemize}

\subsection{PlayManual continuation passing}


\subsection{Optimising |everything|}

Our initial |everything| implementation was presented as:

\begin{code}
everything :: Play on => on -> [on]
everything x = x : concatMap everything $ getChildren x
\end{code}

The disadvantage of this code is that the |concatMap| constructs and consumes the list at every level, requiring one reconstruction per level of depth in the data structure. We can fix this by using continuations:

\begin{code}
everything x = f x []
    where  f :: Play on => on -> [on] -> [on]
           f x rest = x : concatCont (map f $ getChildren x) rest

concatCont []     rest  =  rest
concatCont (x:xs) rest  =  x (concatCont xs rest)
\end{code}

Now we only perform one reconstruction per level. However, we can do better still using GHC's list fusion. The user of everything is likely to be a good consumer, if it is a list comprehension. We can now make |concatCont| a good consumer:

\begin{code}
concatCont xs rest = foldr ($) rest xs
\end{code}

Now we can also make |f| a good producer using |build|:

\begin{code}
everything :: Play on => on -> [on]
everything x = build (f x)
    where
    f :: Play on => on -> (on -> res -> res) -> res -> res
    f x cons nil = x `cons`
        concatCont (map (flip f cons) $ getChildren x) nil
\end{code}


\subsection{Optimising |PlayData|}

The |PlayData| instance is an area of the library we are particularly proud of -- being able to use the existing SYB framework which is already built into the GHC compiler makes boilerplate code much easier to write. Managing to both layer |PlayData| over the |Data| instances, and perform better is not something we initially believed to be possible.

The first optimisation was to move from generating the two elements on the |replaceChildren| tuple separately, to doing it as one task. This means that it is no longer possible to use |gmapM|, but instead we must use |gfoldl|. This reduction means that each data constructor gets examined fewer times, and our use of the state monad can be eliminated.

The second optimisation is to translate to a basic continuation passing style in some places, as per |PlayManual|.

Note the use of case instead of where to make tuples faster.

With all these optimisations in place we perform much the same operations as SYB, but have the overhead of list creation at each step. We are able to push this approach to within about 15\% of the speed of SYB operations.

The next optimisation relies on the extra information present in |Play| operations -- namely the target type. For SYB, the target type could be any node on the graph, while for Play it will have a known type. This means as a node is reached, if there can be no nodes of the target type beneath it, the search does not need to continue. Computing which types are containers for the target type can be done relatively easily with the SYB framework:

\begin{code}
data DataBox = forall a . (Typeable a, Data a) => DataBox a

contains :: (Data a, Typeable a) => a -> [DataBox]
contains x = if isAlgType dtyp then concatMap f ctrs else []
    where
        f ctr = gmapQ DataBox (asTypeOf (fromConstr ctr) x)
        ctrs = dataTypeConstrs dtyp
        dtyp = dataTypeOf x
\end{code}

The |contains| function takes a value which is does not examine, and is always |undefined| in this context. It then returns all fields, and |typeOf| can be performed on each one.

This list of types and their containers can have its transitive closure taken, and all types can be divided into 3 sets -- the singleton set containing the target, the set of types which may contain the target, and the set of types which do not. When examining a node, if its type is a member of the set which does not contain the target, we can prune the search at this point.

This trick is surprisingly effective. Take for example an operation over |Bool| on the value |(True,"Haskell")|. The SYB approach will find 16 nodes, Play will only touch 3 nodes -- as soon as it notices the |String| it will stop. By increasing the length of the string, SYB performs increasingly more work -- Play does not.

We compute the good set for each type only once by using a CAF inside the class to store it. The cost of computing the set is relatively small, and in some larger traversals will pay off during the initial traversal.


\section{Related Work}

This library is intended to be a way to remove the boilerplate for Haskell programs, and it is certainly not the first library to attempt this. Below we compare against some of the more popular alternatives. We have deliberately focused on functional programming -- often generic approaches feel the need to compare to the object-orientated Visitor pattern -- we see it as a different approach for different people.

\subsection{SYB}

Perhaps the most popular boilerplate removal system in Haskell is the SYB approach. One of the reasons for this success is that integration with the GHC compiler, lowering the barrier to use. We have compared directly against traversals written in SYB in the previous section, and also covered how to implement Play in terms of SYB.

\todo{image here}

Both traversals are based on the idea of finding the immediate children of a node. The difference is that Play considers a child to be one of the same type, which may not be immediately below the node. In contrast SYB considers all the immediate children. The above diagram shows the difference, where the orange nodes are all of the same type, and those with a black border are considered children.

While the SYB approach is clearly more logical in an untyped language, in a typed language it requires a considerable amount of trickery to get the types correct. The primary SYB traversal function is:

\begin{code}
gfoldl  ::  (forall a b . Data a => c (a -> b) -> a -> c b)
        ->  (forall g . g -> c g)
        ->  a -> c a

replaceChildren :: on -> ([on], [on] -> on)
\end{code}

In the original SYB paper the authors note ``Trying to understand the type of |gfoldl| directly can lead to brain damage.'' When compared to the type of |replaceChildren|, it is easy to see which is simpler at the type level.

\begin{code}
\end{code}

The basic difference between SYB and Play is the choice of the notion of children. It is reasonably easy to see that SYB is more powerful - there are many nodes in the above example that Play cannot reach. However in a typed language this has come at the cost of substantial type based thought. Play on the other hand simplified things with its alternative definition of child.

We do not include support for many of the other generic features in SYB, such as gread/gshow etc, so they are much more powerful.

We are one of the few traversals who do not have the problem that SYB is compiler integrated, but we are not. We are also faster than SYB.

\subsection{Compos}

The Compos approach is newer than SYB, requiring the GADT's extension along with rank-2 types. While the Compos library can operate over GADT's, it is somewhat restricted to them, requiring an existing data structure to be rewritten as a GADT. The conversion from standard Haskell data structures to GADT's presents several problems: they are GHC specific; deriving is not supported on GADT's; they require explicit type signatures. Some of these problems come about as a result of GADT's being a recent addition.

The Compos approach is also harder to write instances for, having no simple instance generation framework, and no automatic derivation tool (although one could be written). The inner |composOp| operator is very powerful, and indeed we have chosen to replicate it in our library as |descend|. In contrast the Compos library is unable to replicate the query to a list, or the bottom-up traversal.

\subsection{Stratego}

If you think that's "easy", why not use the real thing (Stratego)? You lose type-inference, but you don't need those ugly mk constructors.

http://www.acm.org/crossroads/xrds12-3/stratego.html

\subsection{Attribute Grammars}

Yes, those things are really cool. Have you every looked into Attribute Grammars? It's not quite the same, but still related. See: UUAGC and also Wouter Swierstra's excellent article in the Monad Reader: Why Attribute Grammars Matter.

http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem

http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter

\subsection{Applicative}

\subsection{From Ralf}

Just a few notes. (i) Hugs *does* support rank-2 polymorpism but it does not implement the type class Data I guess, but perhaps it should. Also there is a small chance that hugs' approach to rank-2 is not exactly identical and would trigger issues with SYB. (ii) If you generally prefer exercising a GP setup such that no rank-2 types surface the program, you could use Strafunski. (iii) In particular, have a look at the "polymorphic symphony" paper that uses first-class polymorphism (as opposed to rank-2) and opaque generic function types to set up a library of generic function combinators. Because it uses data types for generic function types, you get full type inference. (iv) You find an older JLAP paper on my web site developing a simple type system for a Stratego-like formal setup.

\section{Conclusions and Future Work}

\acks

The first author is a PhD student supported by a studentship from the Engineering and Physical Sciences Research Council of the UK. Thanks to Bj\"{o}rn Bringert for feedback on an earlier version of this document, Eric Mertens for various ideas and code snippets and Stefan O'Rear for work on the \textsc{Derive} tool.

\bibliographystyle{plainnat}
\bibliography{play}



\end{document}
