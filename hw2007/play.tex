\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{url}
\usepackage{natbib}
\usepackage{datetime}
\usepackage{graphicx}
\usepackage{comment}

%include polycode.fmt
%include play.fmt

% general stuff
\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\C}[1]{\textsf{#1}}
\newcommand{\tup}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\mtxt}[1]{\textsf{#1}}

\newcommand{\pic}[1]{\includegraphics[scale=0.55]{#1.eps}}

% examples
\newcounter{exmp}
\setcounter{exmp}{1}
\newcommand{\yesexample}{\subsubsection*{Example \arabic{exmp}}\addtocounter{exmp}{1}}
\newcommand{\noexample}{\hfill$\Box$}

\newcommand{\todo}[1]{\textbf{\textsc{Todo:} #1}}

% code blocks
\newenvironment{code}{\begin{alltt}\small}{\end{alltt}}
\newenvironment{codepage}
    {\begin{minipage}[h]{\textwidth}\begin{code}}
    {\end{code}\end{minipage}}

\newenvironment{example}{\yesexample}{\noexample}

\newcommand{\K}{\ensuremath{^\ast}} % kleene star
\newcommand{\D}{\ensuremath{\cdot}} % central dot

\renewcommand{\c}[3]{\tup{\T{#1},\T{#2},\T{\{#3\}}}}
\newcommand{\cc}[2]{\c{#1}{$\lambda$}{#2}}

\newcommand{\s}[1]{\ensuremath{_{\tt #1}}} % subscript, in tt font
\newcommand{\g}[1]{\{#1\}} % group, put { } round it
\newcommand{\U}{\textunderscore}
\newcommand{\vecto}[1]{\overrightarrow{#1\;}}
\newcommand{\gap}{\;\;}
\newcommand{\dom}{\text{dom}}


\begin{document}

\conferenceinfo{Haskell Workshop '07}{date, City.} %
\copyrightyear{2007} %
\copyrightdata{[to be supplied]}

\titlebanner{\today{} - \currenttime{}}        % These are ignored unless
\preprintfooter{}   % 'preprint' option specified.

\title{Uniform Boilerplate and List Processing}
\subtitle{}

\authorinfo{Neil Mitchell}
           {York}
           {http://www.cs.york.ac.uk/$\sim$ndm/}
\authorinfo{Colin Runciman}
           {York}
           {http://www.cs.york.ac.uk/$\sim$colin/}

\maketitle

\begin{abstract}
Generic traversals and queries are often referred to as boilerplate code -- they remain relatively similar as the action performed by the code changes, and can often outnumber the actual intent of the code in terms of lines. While other generic traversal schemes have shown how powerful new features can be added to compilers, and how the type system can be manipulated into accepting these operations, this document focuses on a conceptually simpler generic concept. The |Play| class is introduced, which abstracts over common traversals and queries in a simple manner.
\end{abstract}

\section{Introduction}

Generic programming is not a new problem, lots of solutions have been proposed. Let us take a simple example:

\begin{code}
data Expr  =  Val  Int         -- a literal value
           |  Var  String      -- a variable
           |  Neg  Expr        -- negation
           |  Add  Expr  Expr  -- addition
           |  Sub  Expr  Expr  -- subtraction
           |  Mul  Expr  Expr  -- multiplication
           |  Div  Expr  Expr  -- division
\end{code}

This is a small expression language for integer expressions, which permits free variables. To evaluate an expression an initial environment must be supplied mapping the required variables to values. A precondition on this environment is that every variable present in the expression must have a corresponding entry in the environment. This naturally leads to the requirement to specify a function which returns a list of all the variables:

\begin{code}
variables :: Expr -> [String]
variables (Var  x    ) = [x]
variables (Val  x    ) = []
variables (Neg  x    ) = variables x
variables (Add  x y  ) = variables x ++ variables y
variables (Sub  x y  ) = variables x ++ variables y
variables (Mul  x y  ) = variables x ++ variables y
variables (Div  x y  ) = variables x ++ variables y
\end{code}

This code has lots of bad properties:

\begin{itemize}
\item Adding a new constructor would require the program to change.
\item The action part is the first line, but is obscured by the rest of the code.
\item The code is repetitive, and uninteresting.
\item The volume of the code, and the repetitive nature, can lead to subtle bugs, which are easy to overlook.
\item The code is too long.
\end{itemize}

The problem is referred to as the \textit{boilerplate} problem. The boilerplate is that code which doesn't have any interesting meaning, but is there only as a tax on the programmer. Using the framework developed in this paper the above example can be rewritten as:

\begin{code}
variables :: Expr -> [String]
variables x = [y | Var y <- everything x]
\end{code}

\subsection{Contribution}

Of course, this isn't the first technique for removing the boilerplate, the area has been researched extensively. There are a number of novel features in our approach:

\begin{itemize}
\item We restrict ourselves to Haskell 98 where possible, introducing multi-parameter type classes only for more complex problems. Most contrasting approaches requires rank-2 types and/or GADT's.
\item We aim to make the common cases easy, and the reasonably difficult cases possible, and leave the obscure cases alone. By focusing on simplicity we bring real benefits to the programmer.
\item We require the programmer to write only one single function per type to gain access to the operations we provide.
\item We are able make use of the existing compiler support for deriving |Typeable| and |Data|, to provide automatic derivation of our class.
\item Writing additional traversals is trivial, within the reach of even casual users of the library.
\item We compare the relative performance of some traversal mechanisms, something that has been neglected in previous papers.
\item This library has already been used extensively, importantly outside the friends of the authors. Users have remarked at the ease of learning and deploying the library.
\end{itemize}

\subsection{Road map}

\S\ref{sec:combinators} introduces the traversal combinators that we propose, along with short examples. \S\ref{sec:implementation} discusses how these combinators are implemented in terms of a single primitive. \S\ref{sec:multiplay} shows how to extend this approach to more complex data types, at the cost of requiring multi-parameter type classes. \S\ref{sec:rules} lists some properties of our system, and how they can be used for optimisation. \S\ref{sec:syb} gives an implementation of our class in terms of the built in compiler support in GHC. \S\ref{sec:comparison} compares our approach with others, including the ``paradise'' benchmark. \S\ref{sec:performance} gives performance measurements of the various traversal mechanisms. \S\ref{sec:conclusion} makes concluding remarks and suggests directions for future work.


\section{Queries and Traversals}

We define various queries and traversals, using the |Expr| type defined in the introduction as an example throughout. All the traversals rely on the class |Play|, an instance of which is defined for |Expr|. This instance and definition are covered in \S\ref{sec:implementation}.

\subsection{Queries}

This library provides a single method for implementing queries, the |everything| method.

\begin{code}
everything :: Play alpha => alpha -> [alpha]
\end{code}

This function takes a data structure, and returns a list of all data structures of the appropriate type found within it. Given a tree, |everything| returns the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done above. For example:

\begin{code}
everything (Add (Neg (Var "x")) (Val 12)) =
    [Add (Neg (Var "x")) (Val 12)
    ,Neg (Var "x")
    ,Var "x"
    ,Val 12]
\end{code}

\begin{figure}
\pic{everything2}
\caption{Graphical representation of |everything|.}
\label{fig:everything}
\end{figure}

A visual representation of this example is given in Figure \ref{fig:everything}.

One use of this mechanism for querying was given in the introduction. For another example, consider the task of seeing how many divisions by the literal 0 there are -- as this will cause a runtime error.

\begin{code}
countDivZero :: Expr -> Int
countDivZero x = length [() | Div _ (Val 0) <- allOver x]
\end{code}

Note that we make essential use of the feature of list comprehensions that if a pattern does not match, then no errors are returned. In other places of the Haskell language, failing to match a pattern results in a pattern-match error.

Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error. Using the \C{everything} function, all queries can be expressed very quickly and directly.

\subsection{Bottom-up Traversals}

Another common operation covered by many boilerplate removal systems is the traversal.
We define as our standard traversal a bottom up traversal.

\begin{code}
traverse :: Play alpha => (alpha -> alpha) -> alpha -> alpha
\end{code}

Take the example of removing the |Sub| constructor, a little bit of thought leads to the equation:

\begin{code}
x - y == x + (- y)
\end{code}

The desire is then to apply this rewrite at all possible places in the input expression. This can be done with:

\begin{code}
simplify x = traverse f x
    where  f (Sub x y)  = Add x (Neg y)
           f x          = x
\end{code}

This code can be read as applying the subtraction rule where you can, and where you can not, doing nothing.

Adding additional rules is trivial, let us take the example of:

\begin{code}
x + y = 2 * x \text{where} x \equiv y
\end{code}

Now we can add this new rule into our existing traversal:

\begin{code}
simplify x = traverse f x
    where  f (Sub x y)           = Add x (Neg y)
           f (Add x y) | x == y  = Mul (Val 2) x
           f x                   = x
\end{code}

The thing to note about this example is that each rule corresponds to the natural Haskell translation of the rule. The |traverse| function manages all the required boilerplate.

So how does a bottom-up traversal work? The traversal starts by applying the function |f| to all the leaf nodes in the tree, then progressively working up to the root node. The condition on ordering is that before applying |f| to an expression, all the sub-expressions must have had |f| applied.

\subsection{Rewrite Traversals}

Following bottom-up traversals, many boilerplate schemes would define a top-down traversal. Once two traversals have been defined, how should the user pick between them? Instead we focus on modelling traversals as rewrites -- showing why providing a top-down traversal is both unnecessary, and potentially dangerous! There is no barrier to defining a bottom-up traversal in our library -- it is trivial, and we refer to such a hypothetical traversal as |traversal'|.

We define our rewrite traversal to be:

\begin{code}
rewrite :: Play alpha => (alpha -> Maybe alpha) -> alpha -> alpha
rewrite rule x = ...
\end{code}

A |rule| takes an expression of type |alpha|, and returns either |Nothing| to indicate that the rule is not applicable at this root expression, or a |Just| indicating that a modification has been performed, and that the new expression should be checked for rewrites. The postcondition for |rewrite| is that there must be no expressions where |rule| could be applied. Another way of stating this is:

\begin{code}
forall r, x `o` all (isNothing . r) (everywhere (rewrite r x))
\end{code}

It is possible to define this function in terms of |traverse|:

\begin{code}
rewrite :: Play alpha => (alpha -> Maybe alpha) -> alpha -> alpha
rewrite f = traverse g
    where g x = maybe x (rewrite f) (f x)
\end{code}

This function can be seen as trying to apply the rule everywhere in a bottom-up manner, and if at any point if makes a change, then the new tree has the rewrite applied to it. Assuming the set of rules is confluent and terminating, there will be no difference between a top-down and bottom-up application of the rules.

Obviously the disadvantage of |rewrite| is that if the rule modifies a tree only slightly, then large amounts of wasted work could be performed checking expressions repeatedly. Because of this, most programmers would rather use an explicit traversal -- namely top-down or bottom-up, and manage this rewriting themselves. But which one of top-down and bottom-up is most appropriate, and how would it be augmented to ensure |rewrite| behaviour?

\subsubsection{Rewrite as Bottom-Up}

Given a rewrite |f :: alpha -> Maybe alpha|, we can construct |f' :: alpha -> alpha| by |f' x = maybe x id x|. Now what are the preconditions on |f| such that |forall x `o` rewrite f x == traverse f' x|?

There answer is that in |f| the root matching of any equation may not overlap with any of the constructors introduced freshly on the right hand side. For example, taking the traversals from the previous section:

\begin{code}
f (Sub x y)           = Just $ Add x (Neg y)
f (Add x y) | x == y  = Just $ Mul (Val 2) x
f _                   = Nothing
\end{code}

Here |Add| occurs on the right-hand side of the first line, and on the left-hand side of the second. When applied as a single traversal, we can construct a value where the two alternatives differ:

\begin{code}
let x = Sub (Neg (Var "q")) (Var "q")

rewrite   f   x = Mul (Val 2) (Var "q")
traverse  f'  x = Add (Var "q") (Neg (Var "q"))
\end{code}

So is it possible to easily remedy this situation? The answer is yes, whenever the right-hand side introduces a new constructor, an additional onward call can be made:

\begin{code}
f (Sub x y)           = f $ Add x (f $ Neg y)
f (Add x y) | x == y  = f $ Mul (f $ Val 2) x
f x                   = x
\end{code}

This approach guarantees that the traversal is a rewrite, but in fact only one of those |f| calls is necessary, the one attached to the construction of an |Add| value.


\subsubsection{Rewrite at Top-Down}

Now we pose the same question: under what circumstances is a top-down traversal a rewrite, and what modifications can be made to ensure it becomes so?

Before we can answer this question, we must first reflect on what a top-down traversal means. The usual answer is that a modification is on the original tree, at the root. After being modified, the action is re-run upon each of the children.

A sufficient restriction to impose on |f| is that the leaves of left-hand side matches must be distinct from the constructions on the right hand side, although this condition is overly strict. To obtain the correct restriction requires a complete analysis of both the left and right sides.

Note that this restriction is neither strictly more restrictive or less restrictive than the one imposed on bottom-up traversals. \todo{Example}

In a similar manner to bottom-up traversals, we wonder if it is possible to modify |f| minimally to permit a rewrite traversal. The answer is no, consider:

\begin{code}
f (Add (Lit x) (Lit y)  ) = Lit (x+y)
f (Neg (Lit x)          ) = Lit (negate x)
\end{code}

Now choose the value:

\begin{code}
let x = Add (Lit 5) (Neg (Lit 2))

rewrite f x = Lit 3
traverse' f x = Add (Lit 5) (Lit -2)
\end{code}

Now, are we able to find a simple mechanism to go back to obtaining full rewrite behaviour? No. One option is to perform the traversals on the matches of the first equation before doing the match, perhaps a |case| expression -- effectively resulting in a bottom-up traversal. The other option is do rewrite on the entire new right-hand side -- modelling the behaviour of rewrite.


\subsubsection{Summary}

As a result we consider top-down traversals to be more complex and less functional than bottom-up traversals, and we do not include them in our library. An initial version of this library included top-down traversals -- we found they were rarely the correct choice. After investigating further, we discovered that most uses of top-down traversals were to model rewrites where information was pushed down, and most of these functions were wrong in corner cases. This experience lead us to the decision that top-down traversals do not deserve library support.

We include |rewrite| but suspect that most users would be better suited with |traverse|.


\subsection{Action Traversals}

We have introduced rewrite traversals, where the intention was to apply a set of rules until a fixed point was found. The alternative is action traversals, where the order each node wants to be visited and transformed. The |descend| and |traverse| actions can be used to perform this, but a standard technique for allowing actions is to thread a monad through the actions. We do this by introducing |traverseM|, |descendM| and |rewriteM|.

Let us assume that each variable wants to be renamed so it is unique.

\begin{code}
uniqueVars :: Expr -> Expr
uniqueVars x = evalState (traverseM f x)
    where
        vars = ['x':show i | i <- [1..]]
    
        f (Var i)  = do  y:ys <- get
                         put ys
                         return (Var y)
        f x        = return x
\end{code}

Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.


\subsection{Top-Down Descending}

While we have decided that top-down traversals are unnecessary for our library, we still believe that some traversals operate more naturally in a top-down manner. An extension to the top-down traversal includes one where information is pushed downwards at the same time.

Consider the addition of the constructor |Let String Expr Expr| -- binding the variable introduced. In order to determine which variables are used in an unbound manner, we need to ``remember'' which variables have been introduced as we descend. We introduced the |descend| function, taken from the Compos paper \cite{compos}.

\begin{code}
descend :: Play alpha => (alpha -> alpha) -> alpha -> alpha
\end{code}

Now we can write out function with:

\begin{code}
replaceVars :: [(String,Expr)] -> Expr -> Expr
replaceVars rep x =
    case  x of
          Let name bind x -> Let name
              (replaceVars rep bind)
              (replaceVars (filter ((/= name) . fst) rep) x
          Var x -> fromMaybe (Var x) (lookup x rep)
          _ -> descend (replaceVars rep) x
\end{code}

Note that although this function is finished, we have only specified what to do in the two interesting cases, namely |Let| and |Var|.

The |descend| function applies a function to all children of a node, then reconstructs a new result using those results. It is a useful function to have, and often is a better choice than top-down traversals, as it preserves the order you would require, but makes more things explicit.


\subsection{Folds}

Traditionally in Haskell a fold replaces each constructor with an alternative. To define a complete fold on a data type, each constructor must be represented, and there is no obvious library function to abstract over this process. A more useful fold for a library such as this would be to allow a default operation. To do this we have:

\begin{code}
fold :: Play alpha => ([r] -> t) -> (alpha -> t -> r) -> alpha -> r
\end{code}

Now lets imagine that programmers are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.

\begin{code}
depth :: Expr -> Int
depth = fold (foldr max 0) $ const (+1)
\end{code}

Our |fold| function takes two functions, one which combines a list of values representing each child, and one which generates a new value given the value for the children and this particular node. In the above example we have used |foldr max 0| to combine all the children -- |maximum| is inappropriate, as |maximum [] = {-"\bot"-}|. The second function |const (+1)| simply adds one to the previous depth.


\subsection{EverythingContext}

The final operation in the library is a curious one -- we have not seen it referenced in any other library, even in those which attempt to include all variations \cite{replib}. However, if the user requires this particular function, they really do need it -- faking it from other operations requires a lot of monadic complexity. This function was actually contributed by a user, which we feel enhances our claim that average users can construct their own operations upon our framework.

Imagine that you wish to change the value of one literal by one, either increasing or decreasing. This particular operation could be useful for mutation testing. To do this we require the function:

\begin{code}
everythingContext :: Play alpha => alpha -> [(alpha, alpha -> alpha)]
\end{code}

This function returns two lists, one of which is the list as would be returned by everything. The other is the function which would replace the hole which the given expression was removed from. It has the properties:

\begin{code}
forall x `o` everything x == map fst (everythingContext x)
forall x `o` all (== x) [b a | (a,b) <- everythingContext x]
\end{code}

Now we are in a situation to write our function:

\begin{code}
mutants :: Expr -> [Expr]
mutants x =  [gen (Val j)
             | (Val i, gen) <- everythingContext x
             , j <- [i-1, i+1]]
\end{code}


\subsection{Summary}

\begin{figure}
\begin{code}
module Data.Generics.Play where

class Play alpha where
    descend            :: (alpha -> alpha) -> alpha -> alpha
    descendM           :: Monad m => (alpha -> m alpha) -> alpha -> m alpha
    everything         :: alpha -> [alpha]
    everythingContext  :: alpha -> [(alpha, alpha -> alpha)]
    fold               :: ([r] -> t) -> (alpha -> t -> r) -> alpha -> r
    rewrite            :: (alpha -> Maybe alpha) -> alpha -> alpha
    rewriteM           :: Monad m  => (alpha -> m (Maybe alpha))
                                   -> alpha -> m alpha
    traverse           :: (alpha -> alpha) -> alpha -> alpha
    traverseM          :: Monad m => (alpha -> m alpha) -> alpha -> m alpha
\end{code}
\caption{All |Play| methods.}
\label{fig:play}
\end{figure}

We present all our methods in Figure \ref{fig:play}, including several monadic variants. We consider these methods encapsulate most of the common operations. In our experience, the most common operations are |everything| and |traverse|, with |traverseM| being the next most common.


\section{Implementing Play}

Requiring each class to implement nine separate methods would be overly arduous. Instead we implement all of these operations on top of just a single method:

\begin{code}
replaceChildren :: Play alpha => alpha -> ([alpha], [alpha] -> alpha)
\end{code}

The idea is that given an item, you want to return all the children, and a function that will replace all the children. An invariant is that the list given to the second function will be the
same length as that returned in the first element of the pair. The second invariant is:

\begin{code}
forall x `o` x == generate children
    where (children,generate) = replaceChildren x
\end{code}

For example:

\begin{code}
replaceChildren (Add x y) = ([x,y], \[x',y'] -> Add x' y')
\end{code}

The Play class also has one additional method:

\begin{code}
getChildren = fst . replaceChildren
\end{code}

The reason for the addition of |getChildren| is for performance reasons -- some of the operations such as |everything| only require the extraction -- and in some cases it can be implemented more efficient -- see \S\ref{sec:syb_play}.


\subsection{Operations in terms of |replaceChildren|}

Defining operations in terms of |replaceChildren| is easy, we implement the three most common as an example. None is more than a handful of lines long, and none has great deep complexity:

\begin{code}
everything :: Play alpha => alpha -> [alpha]
everything x = x : concatMap everything $ getChildren x

descend :: Play alpha => (alpha -> alpha) -> alpha -> alpha
descend f x = generate $ map f current
    where (current, generate) = replaceChildren x


descendM :: (Monad m, Play alpha) => (alpha -> m alpha) -> alpha -> m alpha
descendM f x = liftM generate $ mapM f current
    where (current, generate) = replaceChildren x
\end{code}

The common pattern is to call replace children, then perform some action on the current children, before combining them back.

Of these operations, some may be slightly optimised -- |everything| requires an excessive number of concatentations -- one for each depth of the tree. In practice an optimised version based on continuation passing is used, still only five lines long.


\subsection{Writing |Play| instances}

While in other generics libraries it is trivial to write the instances, in our case it is more challenging. This is not of a big concern, we have developed automated approaches to deriving these libraries within the \textsc{Derive} tool.

\begin{figure}
\begin{code}
instance Play Expr of
    replaceChildren x =
        case x of
            Neg  a    -> ([a]    , \[a']     -> Neg  a'     )
            Add  a b  -> ([a,b]  , \[a',b']  -> Add  a' b'  )
            Sub  a b  -> ([a,b]  , \[a',b']  -> Sub  a' b'  )
            Mul  a b  -> ([a,b]  , \[a',b']  -> Mul  a' b'  )
            Div  a b  -> ([a,b]  , \[a',b']  -> Div  a' b'  )
            _         -> ([]     , \[]       -> x           )
\end{code}
\caption{Instance of |Play| for |Expr|.}
\label{fig:play_expr}
\end{figure}

We construct a |Play| instance for the |Expr| type in Figure \ref{fig:play_expr}. The pattern of the instance can be seen easily. The default clause has no children of type |Expr|, meaning the leaves have been reached. Some simple combinators are provided to allow these derivations to be written more compactly, but they are not introduced here as they only serve to complicate the story.


\subsection{Derivation Rules}

The distinguishing feature of our libraries is that the children are defined in terms of their type -- while this makes the traversals and queries simpler, it does mean that the definition is dependent on the types of the constructors. We can model the type of an operation with the following construction:

\begin{code}
data Type  =  None
           |  Target
           |  List  Type
           |  Pair  Type Type
\end{code}

While arbitrary sized tuples are supported, along with the |Maybe| type, their rules are no more complex and fit easily into the framework we develop. With this, we define the |<|| `o` ||>| operation, using this we can write a |getChildren| clause as:

\begin{code}
getChildren (C (x1::t1) .. (xn::tn))
    = concat [ <| t1 |> x1, .. , <| tn |> xn]

<| Type         |> :: Type -> [alpha]
<| None         |> = const []
<| Target       |> = (:[])
<| Pair  t1 t2  |> = \(x1,x2) -> <| t1 |> x1 ++ <| t2 |> x2
<| List  t1     |> = concatMap \? <| t1 |>
\end{code}

Having implemented |getChildren|, we can imagine that it may be natural to implement |setChildren|, which could be combined to create |replaceChildren|. For efficiency reasons these two operations are combined into one, requiring only one examination of each constructor, but we present these two methods separately.

\begin{code}
setChildren (C (x1::t1) .. (xn::tn))
    = \ns1 ->  <| t1 |>  x1 ns1  $ \x1'  ns2  ->
               ..
               <| tn |>  xn nsn  $ \xn'  _    ->
               C x1' .. xn'

<| Type         |> :: Type -> [alpha] -> (Type -> [alpha] -> r) -> r
<| None         |> = \x        ns      c -> c x ns
<| Target       |> = \x        (n:ns)  c -> c n ns
<| Pair  t1 t2  |> = \(x1,x2)  ns1     c ->
                               <| t1 |> x1 ns1 $ \x1' ns2 ->
                               <| t2 |> x2 ns2 $ \x2' ns3 ->
                               c (x1',x2') ns3
<| List  t1     |> = list \? <| t1 |>
    where
        list fn []      ns c =  c [] ns
        list fn (x:xs)  ns c =  fn x ns         $ \x'   ns2  ->
                                list fn xs ns2  $ \xs'  ns3  ->
                                c (x':xs') ns3
\end{code}

\subsection{Using Derive}

Apply the presented derivation rules is quite time consuming, and does not produce the cleanest instances. Take for example the type:

\begin{code}
data Term = Name String
          | Apply Term [Term]
\end{code}

The generated code for the instances would be:

\begin{code}
replaceChildren (Name x1) =
    (concat [const [] x1]
    ,\ns1 ->  (\x ns c -> c x ns) x1 ns1 $ \x1' _ ->
              Name x1
    )

replaceChildren (Apply x1 x2) =
    (concat [(:[]) x1, concatMap (:[]) x2]
    ,\ns1 ->  (\x (n:ns) c -> c n ns)         x1 ns1 $ \x1' ns2  ->
              (list (\x (n:ns) c -> c n ns))  x2 ns2 $ \x2' _    ->
              Apply x1' x2'
    )
\end{code}

Through transformation these can be written as:

\begin{code}
replaceChildren (Name x1) =
    ([], \_ -> Name x1)

replaceChildren (Apply x1 x2) =
    (x1:x2, \(n:ns) -> Apply n ns)
\end{code}

Note that the |setChildren| in the |Apply| case changes the strictness -- but assuming the |getChildren| case has been executed first, this is still the same overall strictness.

These transformations are automatically performed by derive.

\section{Multi-variable Play, PlayOn, PlayEx}

 To define the PlayEx class, there are three combinatiors that can be used. These automate much of the definition:

\begin{code}
play :: on -> ([with],[with] -> on)
(/\) :: PlayEx item with => ([with], [with] ->
    item -> on) -> item -> ([with], [with] -> on)
(/\!) :: ([with], [with] -> item -> on) ->
    item -> ([with], [with] -> on)
\end{code}

Note, the above are presented with type signatures for completeness. They are intended to be used mechanically, without excessive thought.

To define a PlayEx instance for the Expr type introduced earlier:

\begin{code}
instance PlayEx Expr a where
    replaceChildrenEx x =
        case x of
            Val a -> play Val /\! a
            Add a b -> play Add /\ a /\ b
            Sub a b -> play Sub /\ a /\ b
            ...
            Neg a -> play Neg /\ a
\end{code}

The definition follows mechanically. The only choice a user makes is whether to use the |(/\)| operator (which recurses into the child on the right), or the |(/\!)| operator, which doesn't. For example, here we have decided not to traverse inside the Int of Val. This can be changed, and would require a PlayEx instance for Int.

If using this style of definition, a special instance must be defined for the self case:

instance PlayEx Expr Expr where
    replaceChildrenEx = playSelf

Unfortunately this requires undecidable instances. A Play instance still needs to be written for each definition.


\subsection{In terms of SYB}

 To define Play and PlayEx instances for all types, in all combinations, simply:

import Data.PlaySYB

data Expr ... deriving (Typeable, Data)

The disadvatages of this are the lack of type safety - you can now do entirely meaningless operations, which the earlier definitions would have spotted as being an error. This code will also only work where Data.Generics is supported, namely GHC at the present time.

The clear advantage is that there is almost no work to creating Play instances.

\begin{figure}
\begin{code}
instance (Data a, Typeable a) => Play a where
    replaceChildren x = fromCC (collect_generate x)

    getChildren x = concat (gmapQ getType x)



instance (Data a, Play b, Typeable a, Typeable b) => PlayEx a b where
    replaceType x = fromCC (collect_generate_self x)

    getType x = res
        where
            res = case asTypeOf (cast x) (Just $ head res) of
                       Just y -> [y]
                       Nothing -> concat $ gmapQ getType x


newtype C x a = C {fromC :: CC x a}

type CC x a = ([x], [x] -> (a, [x]))


fromCC :: CC x a -> ([x], [x] -> a)
fromCC (a, b) = (a, \i -> fst (b i))


collect_generate_self :: (Data on, Play with, Typeable on, Typeable with) => on -> CC with on
collect_generate_self x = res
        where
            res = case asTypeOf (cast x) (Just $ head $ fst res) of
                       Just y -> ([y], \(x:xs) -> (fromJust (cast x), xs))
                       Nothing -> collect_generate x


collect_generate :: (Data on, Play with, Typeable on, Typeable with) => on -> CC with on
collect_generate item = fromC $ gfoldl combine create item
    where
        -- forall a b . Data a => C with (a -> b) -> a -> C with b
        combine (C (c,g)) x = case collect_generate_self x of
                                  (c2, g2) -> C (c2 ++ c, regen g2)
            where
                regen g2 i = case g2 i of
                            (x2,i2) -> case g i2 of
                                (y2,i3) -> (y2 x2, i3)

        -- forall g . g -> C with g
        create x = C ([], \res -> (x, res))
\end{code}
\end{figure}


\section{Properties and optimisation}


\section{The Paradise Benchmark}

\section{Implementation Speed}

\section{Related Work}

\section{Conclusions and Future Work}




\begin{comment}

There have been several attempts at generic traversal/query methods in Haskell. One initial paper was <a href="http://doi.acm.org/10.1145/604174.604179">"Scrap your boilerplate: a practical design pattern for generic programming"</a> (<a href="http://www.cs.vu.nl/boilerplate/tldi03.pdf">free copy</a>) - which I will refer to as SYB. Another mechanism is <a href="http://doi.acm.org/10.1145/1159803.1159834">"A Pattern for Almost Compositional Functions"</a> (<a href="http://www.cs.chalmers.se/%7Ebringert/publ/composOp/composOp.pdf">free copy</a>) - which I refer to as Compos (after the name of their class).

The principle advantage of the Play class over these two papers is that it requires no type system extensions, compared to rank-2 types for SYB and GADT's for Compos. The simplicity of the types required means that the user is free to concentrate on the operations within the class, without requiring thought as to the type trickery required. The Play pattern has been implemented in Yhc for the Core data type, and in Catch on several data types within the program.
</p>
<p>
    This document proceeds as follows:
</p>
<ol>
    <li>The motivation and use cases for Play</li>
    <li>How to use the Play class</li>
    <li>Derivation of a Play instance for your own data type</li>
    <li>Extension to PlayEx</li>
    <li>A comparison to the SYB paper</li>
    <li>A comparison to the Compos paper</li>
</ol>
<p>
    All the examples used in this document can be found in the darcs repository, under the <tt>Examples</tt> directory.
</p>
<pre>
darcs get --partial <a href="http://www.cs.york.ac.uk/fp/darcs/play">http://www.cs.york.ac.uk/fp/darcs/play</a>
</pre>
<p>
    If you only wish to read a small fraction of this document, can I suggest you pay particular attention to <tt>mapUnder</tt> and <tt>allOver</tt> - these are by far the most common transformational patterns.
</p>

<h3>Acknowledgements</h3>

<p>
    Thanks to Bj&ouml;rn Bringert for feedback on an earlier version of this document, Eric Mertens for various ideas and code snippets, and to Matt Naylor and Tom Shackell for helpful discussions.
</p>


<h2>Motivation and Use Cases</h2>

<p>
    The idea behind the Play class is that there exists a data structure, usually with a reasonable number of constructors, which is often transformed or analysed. The usual example of this would be a compiler, which has at its core an expression type. This can be seen as a form of generic programming.
</p>
<p>
    The Play class has the following goals:
</p>
<ul>
    <li>Adding a new constructor should require very few changes</li>
    <li>Traversals should have a minimal amount of boiler plate</li>
    <li>The obvious code should "just work"</li>
    <li>Haskell 98, where possible</li>
    <li>Writing new types of traverals is easy</li>
    <li>The default traversals cover most cases</li>
</ul>
<p>
    The ideas behind the Play class have been used extensively, in both the Yhc compiler and the Catch tool. In Catch there are 109 traversals using the Play class (as at Nov 2006), showing that the Play class gets extensive use.
</p>


<h2>Using Play</h2>

<p>
    These examples revolve around a small arithmetic language, given here:

</p>
<pre>
import Data.Play

data Expr = Val Int
          | Add Expr Expr
          | Sub Expr Expr
          | Div Expr Expr
          | Mul Expr Expr
          | Neg Expr
          deriving (Show, Eq)
</pre>
<p>
    Assume that a Play class has already been written; so now <tt>instance Play Expr</tt> is available to us. Some examples are presented, in rough order of increasingly complexity. These examples are all available in the <tt>Examples/Expr.hs</tt> file.
</p>

<h3>Checking for division by zero</h3>

<pre class="define">
allOver :: Play on => on -> [on]
</pre>
<p>
    If an expression is divided by zero, this causes a runtime error in our language. As part of the compiler, it's nice to give the user a warning message about this. This can be done with the following test:
</p>
<pre>
hasDivZero :: Expr -> Bool
hasDivZero x = not $ null [() | Div _ (Val 0) <- allOver x]
</pre>
<p>
    Here the only Play method being used is <tt>allOver</tt>. Given a tree, <tt>allOver</tt> returns all the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done above. For each division by zero found, any value is created in the list comprehension, and then this is checked to see if anything did match. Returning the count of divide by zero errors is trivial, simply use <tt>length</tt> instead of <tt>not $ null</tt>.  Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error.
</p>
<p>
    <i>Exercise:</i> Write a function to find all literals that occur in an expression, together with their count.
</p>

<h3>Basic optimisation</h3>

<pre class="define">
mapUnder :: Play on => (on -> on) -> on -> on
</pre>
<p>
    If we are negating a literal value, this computation can be performed in advance, so let's write a function to do this.
</p>
<pre>
optimise :: Expr -> Expr
optimise = mapUnder $ \x -> case x of
    Neg (Val i) -> Val (negate i)
    x -> x
</pre>
<p>
    Here the Play method being used is <tt>mapUnder</tt>. This applies the given function to all the children of an expression, before applying it to the parent. This can be thought of as bottom-up traversal of the data structure. There is an equivalent <tt>mapOver</tt> defined, but generally <tt>mapUnder</tt> is used about 90% of the time. The optimise code merely pattern matches on the negation of a literal, and replaces it with the literal. Using mapUnder means that <tt>Neg (Neg (Val 1))</tt> is reduced to <tt>1</tt>, using mapOver would only perform the inner most reduction.

</p>
<p>
    Now lets add another optimisation into the same pass, just before the <tt>x -> x</tt> line insert:
</p>
<pre>
%    Add x y | x == y -> Mul x (Val 2)
</pre>
<p>
    This takes an addition where two terms are equal and changes it into a multiplication, causing the nested expression to be executed only once. This shows that normal Haskell applies, the Play lets you write code as before.
</p>
<p>
    <i>Exercise:</i> Extend the optimisation to so that adding <tt>x</tt> to <tt>Mul x (Val 2)</tt> produces a multiplication by 3.
</p>


<h3>Elimination of Negation</h3>

<pre class="define">
mapOver :: Play on => (on -> on) -> on -> on
</pre>
<p>
    It is possible to eliminate negation entirely, and perhaps this would be a useful computation to perform:
</p>
<pre>
noNegate :: Expr -> Expr
noNegate = mapOver $ \x -> case x of
    Neg (Val i) -> Val (negate i)
    Neg (Neg x) -> x
    Neg (Sub a b) -> Sub b a
    Neg (Add a b) -> Add (Neg a) (Neg b)
    Neg (Div a b) -> Div (Neg a) b
    Neg (Mul a b) -> Mul (Neg a) b
    x -> x
</pre>
<p>
    This is an example where a bottom up traversal would not work, as information is being pushed from the top downwards. Note how each line states a mathematical property, which can be proved in isolation, and that the Play class handles the traverals.
</p>
<p>
    <i>Exercise:</i> Write a similar transformation to eliminate subtraction. These two transformations can be composed, to give a reduced expression language. Can any other expressions be eliminated?
</p>


<h3>Depth of an expression</h3>

<pre class="define">
fold :: Play on => ([res] -> tmp) -> (on -> tmp -> res) -> on -> res
</pre>
<p>
    Now lets imagine that programmers in your language are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.
</p>
<pre>
depth :: Expr -> Int
depth = fold (foldr max 0) $ const (+1)
</pre>
<p>
    This function performs a fold over the data structure. The <tt>foldr max</tt> is being used as maximum, with a starting value of <tt>0</tt>. The next bit simply says that for each iteration, add one to the previous depth.  An evaluator for this expression language can also be modelled as a <tt>fold</tt>, see inside the example directory to see an implementation.
</p>
<p>
    Each <tt>fold</tt> collects all the values from the children of an expression, combines them using the first function, then generates a new value based on the expression. Often the combining function will simply be <tt>id</tt>.
</p>
<p>
    <i>Exercise:</i> Write a function that counts the maximum depth of addition only.
</p>

<h3>Renumbering literals</h3>

<pre class="define">
mapUnderM :: (Monad m, Play on) => (on -> m on) -> on -> m on
</pre>
<p>
    The literal values need to be replaced with a sequence of numbers, each unique. This is unlikely for an arithmetic expression, but consider bound variables in lambda calculus and it starts to become a bit more plausible:
</p>
<pre>
uniqueLits :: Expr -> Expr
uniqueLits x = evalState (mapUnderM f x) [0..]
    where
        f (Val i) = do
            y:ys <- get
            put ys
            return (Val y)
        f x = return x
</pre>
<p>
    Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.
</p>
<p>
    <i>Exercise:</i> Allow each literal to occur only once, when a second occurance is detected, replace that literal with zero.
</p>

<h3>Generating mutants</h3>

<pre class="define">
allOverContext :: Play on => on -> [(on, on -> on)]
</pre>
<p>
    The person who is inputting the expression thinks they made a mistake, they suspect they got one of the values wrong by plus or minus one. Generate all the expressions they might have written.
</p>
<pre>
mutate :: Expr -> [Expr]
mutate x = concat [[gen $ Val $ i-1, gen $ Val $ i+1]
%                   | (Val i, gen) <- allOverContext x]
</pre>
<p>
   The <tt>mapUnder</tt> function is useful for doing an operation to all nodes in a tree, but sometimes you only want to apply a transformation once. This is less common, but is sometimes required. The idea is that the context provides the information required to recreate the original expression, but with this node altered.
</p>
<p>
    <i>Exercise:</i> Replace one multiplication with addition, if there are no multiplications return the original expression.
</p>

<h3>Reverse notation</h3>

<pre class="define">
replaceChildren :: Play on => on -> ([on], [on] -> on)
</pre>
<p>
    In general, <tt>allOver</tt> and <tt>mapUnder</tt> are used most of the time, and <tt>fold</tt> is used occasionally. The Play class is built upon the operation <tt>replaceChildren</tt>, which takes an expression, and returns a pair with the children of that expression, and a function to generate that expression with a new set of children in place. This operation can be directly exploited if required, although should be handled with caution.
</p>
<p>
    Let us make a function that reverses the order of all the inputs, say if the user is working in Right-to-Left mode on their computer:
</p>
<pre>
reverseExpr :: Expr -> Expr
reverseExpr = mapUnder f
    where
        f x = generate $ reverse collect
            where (collect,generate) = replaceChildren x
</pre>
<p>
    This expression does a standard <tt>mapUnder</tt>, but at each iteration calls <tt>replaceChildren</tt>, then reverses the children set before regenerating the original expression. This shows the underlying mechanism on which the library is based, and isn't recommended for average users.
</p>


<h2>Defining a Play instance</h2>

<p>
    As shown in the reversal example (just above), the only method in the Play class is <tt>replaceChildren</tt>. The Play class is defined as:
</p>
<pre class="define">
class Play on where
    replaceChildren :: on -> ([on], [on] -> on)
</pre>
<p>
    The idea is that given an item, you want to return all the children, and a function that will replace all the children. An invariant is that the list given to the second function will be the same length as that returned in the first element of the pair. Let's start by constructing the Play instance for the expression type.
</p>
<pre>
instance Play Expr of
    replaceChildren x =
        case x of
            Add a b -> ([a,b], \[a,b] -> Add a b)
            ...
            Neg a -> ([a], \[a] -> Neg a)
            Val i -> ([], \[] -> Val i)
</pre>
<p>
    A short study of the code should show how this works. The other constructors such as <tt>Mul</tt> follow the same pattern as <tt>Add</tt>. There are some additional combinators defined in the Play class to make this a bit easier.
</p>
<pre>
instance Play Expr of
    replaceChildren x =
        case x of
            Add x y -> playTwo Add x y
            ...
            Neg x   -> playOne Neg x
            x -> playDefault x
</pre>
<p>
    Here <tt>playTwo</tt> takes a constructor of two expressions, and the expressions within them. The function <tt>playOne</tt> operates similarly on one expression. The remaining <tt>playDefault</tt>, which handles <tt>Val</tt> is for expressions with no recursive element.
</p>


<h2>Using PlayEx</h2>

<p>
    The PlayEx class is not standard Haskell, requiring multi-parameter type classes. Where possible try and use the standard Play class. The PlayEx class is necessary when working with a data structure that has multiple types within it.
</p>
<pre class="define">
class Play with => PlayEx on with where
    replaceChildrenEx :: on -> ([with], [with] -> on)
</pre>
<p>
    The <tt>replaceChildrenEx</tt> method operates much like the <tt>replaceChildren</tt>, except for the different types.  When the types of <tt>on</tt> and <tt>with</tt> are different, <tt>replaceChildrenEx</tt> returns the closest children of the requested type. When the types are the same, this function returns the root element, not it's children.
</p>
<p>
    There are three mechanisms for writing <tt>PlayEx</tt> instances:
</p>
<ul>
    <li>Manually - this is quite complex, requires a large number of instance definitions, but needs only multi-parameter type classes, and has a high degree of type safety.</li>
    <li>Combinators - this is reasonably straightforward, requires s moderate number of instance definitions, but needs undecidable instances.</li>
    <li>Scrap Your Boilerplate - this requires SYB support in the compiler (currently GHC only), requires no instance definitions, and has relatively low type safety.</li>
</ul>

<h3>Using the operations from PlayEx</h3>

<p>
    To see various operations being used from the PlayEx class, take a look at <tt>Examples/ComposPaper.hs</tt>. Typically the operations are just the same as Play, with Ex on the end. To use the Ex methods either import Data.PlayMPTC or Data.PlaySYB - depending on how the instances are to be written.
</p>
<pre class="define">
mapUnderEx :: PlayEx on with => (with -> with) -> on -> on
mapUnderExM :: (Monad m, PlayEx on with) => (with -> m with) -> on -> m on
allOverEx :: PlayEx on with => on -> [with]
</pre>

<h3>Defining PlayEx manually</h3>

<p>
    To see an example of this style of definition, see <tt>Examples/ComposBasic.hs</tt>. Here the useful combinations for definitions are:
</p>
<pre class="define">
playExDefault :: (Play on, PlayEx on with) => on -> ([with], [with] -> on)
playSelf :: a -> ([a], [a] -> a)
playMore :: PlayEx a b => (a -> c) -> a -> ([b],[b] -> c)
</pre>
<p>
    The <tt>playSelf</tt> function simply operates on values of the same data type, so typically a defintion will be created such as:
</p>
<pre>
instance PlayEx Expr Expr where
    replaceChildrenEx = playSelf
</pre>
<p>
    The <tt>playExDefault</tt> takes on the same role as <tt>playDefault</tt> - when there are remaining definitions without any further interesting elements in. The <tt>playMore</tt> is designed to continue on the recursion, where elements on interest may lay within other elements.
</p>
<p>
    Defining a PlayEx class using these combinations and direct operations is quite hard, and quite error prone. It is not recommend unless there is no alternative due to implementation restrictions. Note however than even if a PlayEx class is defined with the more powerful tools, an equivalent requiring only MPTC's does exist, so your code is not tied to the extensions forever.
</p>

<h3>Using the PlayEx combinators</h3>

<p>
    To define the <tt>PlayEx</tt> class, there are three combinatiors that can be used. These automate much of the definition:
</p>
<pre class="define">
play :: on -> ([with],[with] -> on)
(/\) :: PlayEx item with => ([with], [with] -> item -> on) -> item -> ([with], [with] -> on)
(/\!) :: ([with], [with] -> item -> on) -> item -> ([with], [with] -> on)
</pre>
<p>
    Note, the above are presented with type signatures for completeness. They are intended to be used mechanically, without excessive thought.
</p>
<p>
    To define a PlayEx instance for the Expr type introduced earlier:
</p>
<pre>
instance PlayEx Expr a where
    replaceChildrenEx x =
        case x of
            Val a -> play Val /\! a
            Add a b -> play Add /\ a /\ b
            Sub a b -> play Sub /\ a /\ b
            ...
            Neg a -> play Neg /\ a
</pre>
<p>
    The definition follows mechanically. The only choice a user makes is whether to use the <tt>(/\)</tt> operator (which recurses into the child on the right), or the <tt>(/\!)</tt> operator, which doesn't. For example, here we have decided not to traverse inside the <tt>Int</tt> of <tt>Val</tt>. This can be changed, and would require a PlayEx instance for <tt>Int</tt>.
</p>
<p>
    If using this style of definition, a special instance must be defined for the self case:
</p>
<pre>
instance PlayEx Expr Expr where
    replaceChildrenEx = playSelf
</pre>
<p>
    Unfortunately this requires undecidable instances. A Play instance still needs to be written for each definition.
</p>

<h3>Using Scrap Your Boilerplate instances</h3>

<p>
    To define Play and PlayEx instances for all types, in all combinations, simply:
</p>
<pre>
import Data.PlaySYB

data Expr ... deriving (Typeable, Data)
</pre>
<p>
    The disadvatages of this are the lack of type safety - you can now do entirely meaningless operations, which the earlier definitions would have spotted as being an error. This code will also only work where <tt>Data.Generics</tt> is supported, namely GHC at the present time.
</p>
<p>
    The clear advantage is that there is almost no work to creating Play instances.
</p>


<h2>Comparison to the SYB Paper</h2>

<p>
    Many of the examples from the original SYB paper are recapped in the Compos paper, so have been covered in the next section. This section focuses on the underlying traversal mechanism employed by both types.
</p>
<p style="text-align:center;">
    <img src="img/syb_vs_play.png" alt="SYB vs Play, notion of children" />
</p>
<p>
    Both traversals are based on the idea of finding the immediate children of a node. The difference is that Play considers a child to be one of the same type, which may not be immediately below the node. In contrast SYB considers all the immediate children. The above diagram shows the difference, where the orange nodes are all of the same type, and those with a black border are considered children.
</p>
<p>
    While the SYB approach is clearly more logical in an untyped language, in a typed language it requires a considerable amount of trickery to get the types correct. The primary SYB traversal function is:
</p>
<pre>
gfoldl :: (forall a b. Term a => w (a -> b)
                              -> a -> w b)
       -> (forall g. g -> w g)
       -> a -> w a
</pre>
<p>
    In the original SYB paper the authors note "Trying to understand the type of <tt>gfoldl</tt> directly can lead to brain damage." When compared to the type of <tt>replaceChildren</tt>, it is easy to see which is simpler at the type level.
</p>
<pre>
replaceChildren :: on -> ([on], [on] -> on)
</pre>
<p>
    The basic difference between SYB and Play is the choice of the notion of children. It is reasonably easy to see that SYB is more powerful - there are many nodes in the above example that Play cannot reach. However in a typed language this has come at the cost of substantial type based thought. Play on the other hand simplified things with its alternative definition of child.
</p>


<h2>Comparison to the Compos Paper</h2>

<p>
    The Compos paper provides a similar mechansim, so the obvious question is how they related. A summary of the advantages and disadvantages is provided, followed by reimplementations of their operations using Play and PlayEx. This code can be found in the <tt>ComposPaper</tt> file. This section is designed to be read with a copy of the Compos paper to hand, alternatives are given, but the tasks are not explained in this section.
</p>
<p>
    Advantages of Play:
</p>
<ul>
    <li>Haskell 98 (the Play class), plus multi-parameter type classes (PlayEx only)</li>
    <li>Does not require GADT's or rank-2 types</li>
    <li>No need to change the data structure</li>
    <li>Less boilerplate in the traversal</li>
    <li>Supports more traversals</li>
</ul>
<p>
    Advantages of Compos:
</p>
<ul>
    <li>Easier to write traversal code (unless using PlaySYB)</li>
    <li>Supports GADT's</li>
</ul>
<p>
    Now I compare the examples in the paper, with the equivalent using Play. The Compos variant is shown in <i>italics</i>.
</p>


<h3>Examples from Section 3</h3>

<p>
    First off, I replicate the data structure from their paper, along with a Play instance.
</p>
<pre>
data Exp = EAbs String Exp
         | EApp Exp Exp
         | EVar String
         deriving Show

instance Play Exp where
    replaceChildren x =
        case x of
            EAbs a c -> playOne (EAbs a) c
            EApp c1 c2 -> playTwo EApp c1 c2
            x -> playDefault x
</pre>

<h3>The <tt>rename</tt> function</h3>

<p>
    Now let us examine the <tt>rename</tt> function. In addition to the Compos and Play versions, I first present the version written <i>without</i> any traveral code:
</p>
<pre>
rename :: Exp -> Exp
rename e = case e of
    EAbs x b -> EAbs ("_" ++ x) (rename b)
    EApp c a -> EApp (rename c) (rename a)
    EVar x   -> EVar ("_" ++ x)
</pre>
<p>
    And now the two variants from the libraries:
</p>
<pre class="compos">
rename :: Exp -> Exp
rename e = case e of
    EAbs x b -> EAbs ("_" ++ x) (rename b)
    EVar x   -> EVar ("_" ++ x)
    _        -> composOp rename e
</pre>
<pre class="play">
rename :: Exp -> Exp
rename = mapUnder $ \e -> case e of
    EAbs s x -> EAbs ("_" ++ s) x
    EVar s -> EVar ("_" ++ s)
    x -> x
</pre>
<p>
    Note that in the Compos version there is only one function, in contrast to two in the Play version. However, in the Play version the traversal code is at the top, whereas with Compos it is the base case. Also note that in <tt>EAbs</tt> Compos has to continue the recursion, if the <tt>(rename b)</tt> call was missed then this would not work - Play takes care of this detail automatically.
</p>


<h3>The <tt>free</tt> function</h3>

<pre class="compos">
free :: Exp -> [String]
free e = case e of
    EAbs x b -> delete x (free b)
    EVar x -> [x]
    _ -> composOpFold [] union free e
</pre>
<pre class="play">
free :: Exp -> [String]
free = fold (nub . concat) $ \e y -> case e of
    EAbs s x -> delete s y
    EVar s -> [s]
    x -> y
</pre>
<p>
    In this function the two approaches are relatively similar, in Compos the fold information is at the bottom, in Play it is at the top. Play gives slightly more freedom by allowing the combining function to combine a list in the heirarchy at a time, while Compos only lets a merge function merge two elements.
</p>

<h3>The <tt>fresh</tt> function</h3>

<pre class="compos">
fresh :: Exp -> Exp
fresh x = evalState (f [] x) names
    where
        names = ["_" ++ show n | n <- [0..]]
        f vs t = case t of
            EAbs x b -> do
                y:fs <- get
                put fs
                liftM (EAbs y) (f ((x,y):vs) b)
            EVar x ->
                return (EVar (fromMaybe x (lookup x vs)))
            _ -> composOpM (f vs) t
</pre>
<pre class="play">
fresh :: Exp -> Exp
fresh x = evalState (f [] x) names
    where
        names = ["_" ++ show n | n <- [0..]]
        f vs t = case t of
            EAbs x b -> do
                y:fs <- get
                put fs
                liftM (EAbs y) (f ((x,y):vs) b)
            EVar x ->
                return (EVar (fromMaybe x (lookup x vs)))
            _ -> composM (f vs) t
</pre>
<p>
    In this particular example, none of the built in traversals provided by Play are much better than Compos, so instead the <tt>compos</tt> operator has been defined in the Play framework. This shows that anything Compos can do, Play can copy at the very least. (The code from the Compos example has been updated to use <tt>Control.Monad.State</tt>, to make it more accessible)
</p>

<h3>Examples from Section 4</h3>

<p>
    The types manipulated by Secion 4 are:
</p>
<pre>
data Stm = SDecl Typ Var
         | SAss  Var Exp
         | SBlock [Stm]
         | SReturn Exp

data Exp = EStm Stm
         | EAdd Exp Exp
         | EVar Var
         | EInt Int

data Var = V String

% data Typ = T_int | T_float
</pre>
<p>
    The first thing done by the Compos paper is to translate this into a GADT, which destroys abstraction. If a data structure representing a program was also defined, then this would have to be merged into the single GADT. Play on the other hand accepts the definition as supplied.
</p>
<p>
    The manual PlayEx instances for this data structure are not particularly nice, this is mainly due to the decision to have <tt>EStm</tt> in the <tt>Exp</tt> data type. A much more natural definition would be either to merge <tt>Stm</tt> and <tt>Exp</tt>, or to add <tt>SExp</tt> to <tt>Stm</tt>. If either of these things were done, then the Play instances would be vastly simplified. Because of the ugliness of the manual Play instances, I merely list the instances defined, the code for them is available in the example.
</p>
<pre>
instance Play Stm
instance Play Exp
instance Play Var

instance PlayEx Stm Stm
instance PlayEx Exp Exp
instance PlayEx Stm Exp
instance PlayEx Exp Stm
instance PlayEx Stm Var
instance PlayEx Exp Var
</pre>
<p>
    Of course, it is possible to write the Play instances using the PlayEx combinators (if we are willing to pay for undecidable instances), and for Exp this is shown:
</p>
<pre>
instance Play Exp where
    replaceChildren x =
        case x of
            EStm s -> playMore EStm s
            EAdd a b -> playTwo EAdd a b
            x -> playDefault x

instance PlayEx Exp Exp where; replaceChildrenEx = playSelf

instance Play a => PlayEx Exp a where
    replaceChildrenEx x =
        case x of
            EStm a -> play EStm /\ a
            EAdd a b -> play EAdd /\ a /\ b
            EVar a -> play EVar /\ a
            EInt a -> play EInt /\! a
</pre>
<p>
    These instances are more work than Compos, in particlar two copies have to be written compared to Compos, but they are at least relatively straight forward. If this is still too much work then:
</p>
<pre>
data Stm = ... deriving (Data,Typeable)
data Exr = ... deriving (Data,Typeable)
data Var = ... deriving (Data,Typeable)
</pre>
<p>
    This permits the use of the SYB definitions, at the cost of some type safety. No instances need to be written at all.
</p>
<p>
    While the choice of how to write the underlying functions is much more confusing with Play, compared to Compos, there is a good deal of flexibility. Depending on what features a user wishes to leverage, progressively shorter Play definitions can be specified. Hopefully the cost of writing instances will be low, compared to the use of Play functions. In one project the ratio is about 1:50, which supports this argument.
</p>

<h3>The <tt>rename</tt> function</h3>

<pre class="compos">
rename :: Tree c -> Tree c
rename t = case t of
    V x -> V ("_" ++ x)
    _   -> composOp rename t
</pre>
<pre class="play">
rename :: PlayEx x Var => x -> x
rename = mapUnderEx $ \(V x) -> V ("_" ++ x)
</pre>
<p>
    The first thing to note is the Play function is shorter, there is only one constructor in type <tt>Var</tt>. In contrast Compos has merged all constructors into one GADT, and can not benefit from this. The Compos function works over all trees, including those based on <tt>Typ</tt>, which is meaningless, since types do not contain variables. The Play class only operates on <tt>Exp</tt> and <tt>Stm</tt> types.
</p>

<h3>The <tt>warnAssign</tt> function</h3>

<pre class="compos">
warnAssign :: Tree c -> IO ()
warnAssign t = case t of
    SAss _ _ -> putChar (chr 7)
    _ -> composM_ warnAssign t
</pre>
<pre class="play">
warnAssign :: PlayEx x Stm => x -> IO ()
warnAssign = mapUnderExM_ $ \x -> case x of
    SAss _ _ -> putChar (chr 7)
    _ -> return ()
</pre>
<p>
    Here the traversals are very similar, both threading a Monad through the code. This example shows how monadic actions can be threading through a traversal, however, this is not usually necessary. Using the Play class, a more natural traversal emerges:
</p>
<pre class="play">
warnAssign :: PlayEx x Stm => x -> IO ()
warnAssign x = putStr [chr 7 | SAss{} <- allOverEx x]
</pre>
<p>
    Here the Play class is very concise. The Play approach extracts the relevant bits with a list comprehension. Hopefully this shows how analysis functions can often be implemented with <tt>allOver</tt>, rathern than a traversal. The Compos version could be written using a fold, which would reduce it's complexity, although would still be more complex than the Compos version.
</p>


<h3>The <tt>symbols</tt> function</h3>

<pre class="compos">
symbols :: Tree c -> [(Tree Var, Tree Typ)]
symbols t = case t of
    SDecl typ var -> [(var,typ)]
    _ -> composOpMonoid symbols t
</pre>
<pre class="play">
symbols :: PlayEx x Stm => x -> [(Var,Typ)]
symbols x = [(v,t) | SDecl t v <- allOverEx x]
</pre>
<p>
    Here the Compos function does a traversal of the tree, however again the Play class simply extracts the right bits. This example is almost identical to the previous <tt>warnAssign</tt> using Play, however the Compos approach introduces distinctions by requiring a more ordered approach to traversal.
</p>

<h3>The <tt>constFold</tt> function</h3>

<pre class="compos">
constFold :: Tree c -> Tree c
constFold e = case e of
    EAdd x y -> case (constFold x, constFold y) of
                    (EInt n, EInt m) -> EInt (n+m)
                    (x',y') -> EAdd x' y'
    _ -> composOp constFold e
</pre>
<pre class="play">
constFold :: PlayEx x Exp => x -> x
constFold = mapUnderEx $ \e -> case e of
    EAdd (EInt n) (EInt m) -> EInt (n+m)
    x -> x
</pre>
<p>
    The constant folding operation is a bottom-up traversal, requiring sub expressions to have been replaced before they are examined. Unfortunately Compos only supports top-down traversals, requiring the user to manually do a small traversal in the middle. Play supports both types of traversals, and experience has shown that bottom-up is almost always what the user wants. This allows Play to produce shorter code.
</p>


<h3>Section 7.1.1</h3>

<p>
    The examples in Section 7.1.1 require lots of data types and lots of different styles of traversal. As such manual Play instances would not really be appropriate for this type of task - the instances would take too long to write. If we use the SYB instances, by importing <tt>Data.PlaySYB</tt> then we can start and take a look at the traversals. For this section, the SYB instance is presented first, followed by the Compos one, followed by the Play one.
</p>
<p>
    For completeness the data definition is reproduced here. For SYB and Play, deriving clauses have to be added. For Compos the whole thing is replaced by a GADT. All the code for Play is in the file <tt>Examples/SYB.hs</tt>.
</p>
<pre>
data Company = C [Dept]
data Dept = D Name Manager [Unit]
%data Unit = PU Employee | DU Dept
data Employee = E Person Salary
data Person = P Name Address
data Salary = S Float
type Manager = Employee
type Name = String
type Address = String
</pre>

<h3>The <tt>increase</tt> function</h3>

<pre class="syb">
increase :: Data a => Float -> a -> a
increase k = everywhere (mkT (incS k))

incS :: Float -> Salary -> Salary
incS k (S s) = S (s * (1+k))
</pre>
<pre class="compos">
increase :: Float -> Tree c -> Tree c
increase k c = case c of
    S s -> S (s * (1+k))
    _ -> composOp (increase k) c
</pre>
<pre class="play">
increase :: PlayEx x Salary => Float -> x -> x
increase k = mapUnderEx (\(S s) -> S (s * (1+k)))
</pre>
<p>
    Here the Play uses seems to be the most intuative. It requires no rank-2 types, no GADT's, and yet still provides the shortest code. The SYB approach requires separate functions to get the type classes working, and use of rather complex intermediates such as <tt>mkT</tt> and <tt>everywhere</tt>. The Compos function appears to be much simpler than SYB, but by merging all the data constructors has to perform a case on the value. By keeping the original structure intact, Play can simply state the property.
</p>

<h3>The <tt>incrOne</tt> function</h3>

<pre class="syb">
incrOne :: Data a => Name -> Float -> a -> a
incrOne n k a | isDept n a = increase k a
              | otherwise = gmapT (incrOne n k) a

isDept :: Data a => Name -> a -> Bool
isDept n = False `mkQ` isDeptD n

isDeptD :: Name -> Dept -> Bool
isDeptD n (D n2 _ _) = n==n2
</pre>
<pre class="compos">
incrOne :: Name -> Float -> Tree c -> Tree c
incrOne d k c = case c of
    D n _ _ | n == d -> increase k c
    _ -> composOp (incrOne d k) c
</pre>
<pre class="play">
incrOne :: PlayEx x Dept => String -> Float -> x -> x
incrOne name k = mapUnderEx (\d@(D n _ _) -> if name == n then increase k d else d)
</pre>
<p>
    Here SYB has grown substantially more complex, to accomodate the invariant, requiring two different utility functions. Compos still retains the same structure as before, requiring a case to distinguish between the types of constructor. Play remains shorter - although in this case the complexity is roughly the same as the Compos solution.
</p>

<h3>The <tt>salaryBill</tt> function</h3>

<pre class="syb">
salaryBill :: Company -> Float
salaryBill = everything (+) (0 `mkQ` billS)

billS :: Salary -> Float
billS (S f) = f
</pre>
<pre class="compos">
salaryBill :: Tree c -> Float
salaryBill c = case c of
    S s -> s
    _ -> composOpFold 0 (+) salaryBill c
</pre>
<pre class="play">
salaryBill :: PlayEx x Salary => x -> Float
salaryBill x = sum [x | S x <- allOverEx x]
</pre>
<p>
    Here the Play instance wins by being able to use a list comprehension to select the salary value out of a Salary object. The Play class is the only one that is able to use the standard Haskell <tt>sum</tt> function, not requiring an explicit fold to be performed. In this case it could easily be argued that <tt>billS</tt> is probably a general function, so the cost of writting it is not really correctly attributed to the SYB approach. If <tt>billS</tt> is a generally defined function, then you can rewrite the Play example as:
</p>
<pre class="play">
salaryBill2 :: PlayEx x Salary => x -> Float
salaryBill2 = sum . map billS . allOverEx
</pre>
<p>
    This solution is nice in that it is a very specification orientated view of the problem. Take all the salaries, get their value, and sum them.
</p>



% \appendix
% \section{Appendix Title}
%
% Here is the text of the appendix, if you need one.

\acks

The first author is a PhD student supported by a studentship from the Engineering and Physical Sciences Research Council of the UK.
\end{comment}

\bibliographystyle{plainnat}
\bibliography{play}



\end{document}
