\documentclass[preprint]{sigplanconf}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{alltt}
\usepackage{url}
\usepackage{natbib}
\usepackage{datetime}
\usepackage{graphicx}
\usepackage{comment}

%include polycode.fmt
%include play.fmt

% general stuff
\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\C}[1]{\textsf{#1}}
\newcommand{\tup}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\mtxt}[1]{\textsf{#1}}

\newcommand{\pic}[1]{\includegraphics[scale=0.55]{#1.eps}}

% examples
\newcounter{exmp}
\setcounter{exmp}{1}
\newcommand{\yesexample}{\subsubsection*{Example \arabic{exmp}}\addtocounter{exmp}{1}}
\newcommand{\noexample}{\hfill$\Box$}

\newcommand{\todo}[1]{\textbf{\textsc{Todo:} #1}}

% code blocks
\newenvironment{code}{\begin{alltt}\small}{\end{alltt}}
\newenvironment{codepage}
    {\begin{minipage}[h]{\textwidth}\begin{code}}
    {\end{code}\end{minipage}}

\newenvironment{example}{\yesexample}{\noexample}

\newcommand{\K}{\ensuremath{^\ast}} % kleene star
\newcommand{\D}{\ensuremath{\cdot}} % central dot

\renewcommand{\c}[3]{\tup{\T{#1},\T{#2},\T{\{#3\}}}}
\newcommand{\cc}[2]{\c{#1}{$\lambda$}{#2}}

\newcommand{\s}[1]{\ensuremath{_{\tt #1}}} % subscript, in tt font
\newcommand{\g}[1]{\{#1\}} % group, put { } round it
\newcommand{\U}{\textunderscore}
\newcommand{\vecto}[1]{\overrightarrow{#1\;}}
\newcommand{\gap}{\;\;}
\newcommand{\dom}{\text{dom}}

\newcommand{\derive}{\textsc{Derive}}


\begin{document}

\conferenceinfo{Haskell Workshop '07}{date, City.} %
\copyrightyear{2007} %
\copyrightdata{[to be supplied]}

\titlebanner{\today{} - \currenttime{}}        % These are ignored unless
\preprintfooter{}   % 'preprint' option specified.

\title{Scrap Your Scary Types}
\subtitle{Uniform Boilerplate with Lists}

\authorinfo{Neil Mitchell}
           {York}
           {http://www.cs.york.ac.uk/$\sim$ndm/}
\authorinfo{Colin Runciman}
           {York}
           {http://www.cs.york.ac.uk/$\sim$colin/}

\maketitle

\begin{abstract}
Generic traversals and queries are often referred to as boilerplate code -- they remain relatively similar as the action performed by the code changes, and can often outnumber the actual intent of the code in terms of lines. While other generic traversal schemes have shown how powerful new features can be added to compilers, and how the type system can be manipulated into accepting these operations, this paper focuses on a conceptually simpler generic concept. The |Play| class is introduced, which abstracts over common traversals and queries in a simple manner.
\end{abstract}

\section{Introduction}

Generic programming is not a new problem, lots of solutions have been proposed. Let us take a simple example:

\begin{code}
data Expr  =  Val  Int         -- a literal value
           |  Var  String      -- a variable
           |  Neg  Expr        -- negation
           |  Add  Expr  Expr  -- addition
           |  Sub  Expr  Expr  -- subtraction
           |  Mul  Expr  Expr  -- multiplication
           |  Div  Expr  Expr  -- division
\end{code}

This is a small expression language for integer expressions, which permits free variables. To evaluate an expression an initial environment must be supplied mapping the required variables to values. A precondition on this environment is that every variable present in the expression must have a corresponding entry in the environment. This naturally leads to the requirement to specify a function which returns a list of all the variables:

\begin{code}
variables :: Expr -> [String]
variables (Var  x    ) = [x]
variables (Val  x    ) = []
variables (Neg  x    ) = variables x
variables (Add  x y  ) = variables x ++ variables y
variables (Sub  x y  ) = variables x ++ variables y
variables (Mul  x y  ) = variables x ++ variables y
variables (Div  x y  ) = variables x ++ variables y
\end{code}

This code has lots of bad properties:

\begin{itemize}
\item Adding a new constructor would require the program to change.
\item The action part is the first line, but is obscured by the rest of the code.
\item The code is repetitive, and uninteresting.
\item The volume of the code, and the repetitive nature, can lead to subtle bugs, which are easy to overlook.
\item The code is too long.
\end{itemize}

The problem is referred to as the \textit{boilerplate} problem. The boilerplate is that code which doesn't have any interesting meaning, but is there only as a tax on the programmer. Using the framework developed in this paper the above example can be rewritten as:

\begin{code}
variables :: Expr -> [String]
variables x = [y | Var y <- everything x]
\end{code}

Note that in the above example the type signature is optional, and would be inferred automatically if left absent.

\subsection{Contribution}

Of course, this isn't the first technique for removing the boilerplate, the area has been researched extensively. There are a number of novel features in our approach:

\begin{itemize}
\item We restrict ourselves to Haskell 98 where possible, introducing multi-parameter type classes only for more complex problems. Most contrasting approaches requires rank-2 types and/or GADT's.
\item We aim to make the common cases easy, and the reasonably difficult cases possible, and leave the obscure cases alone. By focusing on simplicity we bring real benefits to the programmer.
\item We require the programmer to write only one single function per type to gain access to the operations we provide.
\item We are able make use of the existing compiler support for deriving |Typeable| and |Data|, to provide automatic derivation of our class.
\item Writing additional traversals is trivial, within the reach of even casual users of the library.
\item We compare the relative performance of some traversal mechanisms, something that has been neglected in previous papers.
\item This library has already been used extensively, importantly outside the friends of the authors. Users have remarked at the ease of learning and deploying the library.
\item Our choice of traversals is new, we shun some traditionally provided operations, and provide some which have not been seen before.
\end{itemize}

We have implemented all our code, and encourage you to download it and try it out. It can be obtained from the website at \url{http://www.cs.york.ac.uk/~ndm/play/}. A copy of the library has also been released, and is on Hackage.

The ideas behind the Play class have been used extensively, in both the Yhc compiler and the Catch tool. In Catch there are 109 traversals using the Play class (as at Nov 2006), showing that the Play class gets extensive use.

\subsection{Road map}

\S\ref{sec:combinators} introduces the traversal combinators that we propose, along with short examples. \S\ref{sec:implementation} discusses how these combinators are implemented in terms of a single primitive. \S\ref{sec:multiplay} shows how to extend this approach to more complex data types, at the cost of requiring multi-parameter type classes. \S\ref{sec:rules} lists some properties of our system, and how they can be used for optimisation. \S\ref{sec:syb} gives an implementation of our class in terms of the built in compiler support in GHC. \S\ref{sec:comparison} compares our approach with others, including the ``paradise'' benchmark. \S\ref{sec:performance} gives performance measurements of the various traversal mechanisms. \S\ref{sec:conclusion} makes concluding remarks and suggests directions for future work.


\section{Queries and Traversals}

We define various queries and traversals, using the |Expr| type defined in the introduction as an example throughout. All the traversals rely on the class |Play|, an instance of which is defined for |Expr|. This instance and definition are covered in \S\ref{sec:implementation}.

\subsection{Queries}

This library provides a single method for implementing queries, the |everything| method.

\begin{code}
everything :: Play alpha => alpha -> [alpha]
\end{code}

This function takes a data structure, and returns a list of all data structures of the appropriate type found within it. Given a tree, |everything| returns the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done in the Inroduction. For example:

\begin{code}
everything (Add (Neg (Var "x")) (Val 12)) =
    [Add (Neg (Var "x")) (Val 12)
    ,Neg (Var "x")
    ,Var "x"
    ,Val 12]
\end{code}

\begin{figure}
\pic{everything2}
\caption{Graphical representation of |everything|.}
\label{fig:everything}
\end{figure}

A visual representation of this example is given in Figure \ref{fig:everything}.

One use of this mechanism for querying was given in the introduction. For another example, consider the task of seeing how many divisions by the literal 0 there are -- as this will cause a runtime error.

\begin{code}
countDivZero :: Expr -> Int
countDivZero x = length [() | Div _ (Val 0) <- everything x]
\end{code}

Note that we make essential use of the feature of list comprehensions that if a pattern does not match, then no errors are returned. In other places of the Haskell language, failing to match a pattern results in a pattern-match error.

Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error. Using the \C{everything} function, all queries can be expressed very quickly and directly.

\subsection{Bottom-up Traversals}

Another common operation covered by many boilerplate removal systems is the traversal.
We define as our standard traversal a bottom up traversal.

\begin{code}
traverse :: Play alpha => (alpha -> alpha) -> alpha -> alpha
\end{code}

Take the example of removing the |Sub| constructor, a little bit of thought leads to the equation:

\begin{code}
x - y == x + (- y)
\end{code}

The desire is then to apply this rewrite at all possible places in the input expression. This can be done with:

\begin{code}
simplify x = traverse f x
    where  f (Sub x y)  = Add x (Neg y)
           f x          = x
\end{code}

This code can be read as applying the subtraction rule where you can, and where you can not, doing nothing.

Adding additional rules is trivial, let us take the example of:

\begin{code}
x + y | x == y = 2 * x
\end{code}

Now we can add this new rule into our existing traversal:

\begin{code}
simplify x = traverse f x
    where  f (Sub x y)           = Add x (Neg y)
           f (Add x y) | x == y  = Mul (Val 2) x
           f x                   = x
\end{code}

The thing to note about this example is that each rule corresponds to the natural Haskell translation of the rule. The |traverse| function manages all the required boilerplate.

So how does a bottom-up traversal work? The traversal starts by applying the function |f| to all the leaf nodes in the tree, then progressively working up to the root node. The condition on ordering is that before applying |f| to an expression, all the sub-expressions must have had |f| applied.

\subsection{Rewrite Traversals}

Following bottom-up traversals, many boilerplate schemes would define a top-down traversal. Once two traversals have been defined, how should the user pick between them? Instead we focus on modelling traversals as rewrites -- showing why providing a top-down traversal is both unnecessary, and potentially dangerous! There is no barrier to defining a bottom-up traversal in our library -- it is trivial, and we refer to such a hypothetical traversal as |traversal'|.

We define our rewrite traversal to be:

\begin{code}
rewrite :: Play alpha => (alpha -> Maybe alpha) -> alpha -> alpha
rewrite rule x = ...
\end{code}

A |rule| takes an expression of type |alpha|, and returns either |Nothing| to indicate that the rule is not applicable at this root expression, or a |Just| indicating that a modification has been performed, and that the new expression should be checked for rewrites. The postcondition for |rewrite| is that there must be no expressions where |rule| could be applied. Another way of stating this is:

\begin{code}
forall r, x `o` all (isNothing . r) (everywhere (rewrite r x))
\end{code}

It is possible to define this function in terms of |traverse|:

\begin{code}
rewrite :: Play alpha => (alpha -> Maybe alpha) -> alpha -> alpha
rewrite f = traverse g
    where g x = maybe x (rewrite f) (f x)
\end{code}

This function can be seen as trying to apply the rule everywhere in a bottom-up manner, and if at any point if makes a change, then the new tree has the rewrite applied to it. Assuming the set of rules is confluent and terminating, there will be no difference between a top-down and bottom-up application of the rules.

Obviously the disadvantage of |rewrite| is that if the rule modifies a tree only slightly, then large amounts of wasted work could be performed checking expressions repeatedly. Because of this, most programmers would rather use an explicit traversal -- namely top-down or bottom-up, and manage this rewriting themselves. But which one of top-down and bottom-up is most appropriate, and how would it be augmented to ensure |rewrite| behaviour?

\subsubsection{Rewrite as Bottom-Up}

Given a rewrite |f :: alpha -> Maybe alpha|, we can construct |f' :: alpha -> alpha| by |f' x = maybe x id (f x)|. Now what are the preconditions on |f| such that |forall x `o` rewrite f x == traverse f' x|?

The answer is that in |f| the root matching of any equation may not overlap with any of the constructors introduced freshly on the right hand side. For example, taking the traversals from the previous section:

\begin{code}
f (Sub x y)           = Just $ Add x (Neg y)
f (Add x y) | x == y  = Just $ Mul (Val 2) x
f _                   = Nothing
\end{code}

Here |Add| occurs on the right-hand side of the first line, and on the left-hand side of the second. When applied as a single traversal, we can construct a value where the two alternatives differ:

\begin{code}
let x = Sub (Neg (Var "q")) (Var "q")

rewrite   f   x = Mul (Val 2) (Var "q")
traverse  f'  x = Add (Var "q") (Neg (Var "q"))
\end{code}

So is it possible to easily remedy this situation? The answer is yes, whenever the right-hand side introduces a new constructor, an additional onward call can be made:

\begin{code}
f (Sub x y)           = f $ Add x (f $ Neg y)
f (Add x y) | x == y  = f $ Mul (f $ Val 2) x
f x                   = x
\end{code}

This approach guarantees that the traversal is a rewrite, but in fact only one of those |f| calls is necessary, the one attached to the construction of an |Add| value.


\subsubsection{Rewrite as Top-Down}

Now we pose the same question: under what circumstances is a top-down traversal a rewrite, and what modifications can be made to ensure it becomes so?

Before we can answer this question, we must first reflect on what a top-down traversal means. The usual answer is that a modification is on the original tree, at the root. After being modified, the action is re-run upon each of the children.

A sufficient restriction to impose on |f| is that the leaves of left-hand side matches must be distinct from the constructions on the right hand side, although this condition is overly strict. To obtain the correct restriction requires a complete analysis of both the left and right sides.

Note that this restriction is neither strictly more restrictive or less restrictive than the one imposed on bottom-up traversals. \todo{Example}

In a similar manner to bottom-up traversals, we wonder if it is possible to modify |f| minimally to permit a rewrite traversal. The answer is no, consider:

\begin{code}
f (Add (Lit x) (Lit y)  ) = Lit (x+y)
f (Neg (Lit x)          ) = Lit (negate x)
\end{code}

Now choose the value:

\begin{code}
let x = Add (Lit 5) (Neg (Lit 2))

rewrite f x = Lit 3
traverse' f x = Add (Lit 5) (Lit -2)
\end{code}

Now, are we able to find a simple mechanism to go back to obtaining full rewrite behaviour? No. One option is to perform the traversals on the matches of the first equation before doing the match, perhaps a |case| expression -- effectively resulting in a bottom-up traversal. The other option is do rewrite on the entire new right-hand side -- modelling the behaviour of rewrite.


\subsubsection{Summary}

As a result we consider top-down traversals to be more complex and less functional than bottom-up traversals, and we do not include them in our library. An initial version of this library included top-down traversals -- we found they were rarely the correct choice. After investigating further, we discovered that most uses of top-down traversals were to model rewrites where information was pushed down, and most of these functions were wrong in corner cases. This experience lead us to the decision that top-down traversals do not deserve library support.

We include |rewrite| but suspect that most users would be better suited with |traverse|.


\subsection{Action Traversals}

We have introduced rewrite traversals, where the intention was to apply a set of rules until a fixed point was found. The alternative is action traversals, where the order each node wants to be visited and transformed. The |descend| and |traverse| actions can be used to perform this, but a standard technique for allowing actions is to thread a monad through the actions. We do this by introducing |traverseM|, |descendM| and |rewriteM|.

Let us assume that each variable wants to be renamed so it is unique.

\begin{code}
uniqueVars :: Expr -> Expr
uniqueVars x = evalState (traverseM f x) vars
    where
        vars = ['x':show i | i <- [1..]]

        f (Var i)  = do  y:ys <- get
                         put ys
                         return (Var y)
        f x        = return x
\end{code}

Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.


\subsection{Top-Down Descending}

While we have decided that top-down traversals are unnecessary for our library, we still believe that some traversals operate more naturally in a top-down manner. An extension to the top-down traversal includes one where information is pushed downwards at the same time.

Consider the addition of the constructor |Let String Expr Expr| -- binding the variable introduced. In order to determine which variables are used in an unbound manner, we need to ``remember'' which variables have been introduced as we descend. We introduced the |descend| function, taken from the Compos paper \cite{compos}.

\begin{code}
descend :: Play alpha => (alpha -> alpha) -> alpha -> alpha
\end{code}

Now we can write out function with:

\begin{code}
replaceVars :: [(String,Expr)] -> Expr -> Expr
replaceVars rep x =
    case  x of
          Let name bind x -> Let name
              (replaceVars rep bind)
              (replaceVars (filter ((/= name) . fst) rep) x
          Var x -> fromMaybe (Var x) (lookup x rep)
          _ -> descend (replaceVars rep) x
\end{code}

Note that although this function is finished, we have only specified what to do in the two interesting cases, namely |Let| and |Var|.

The |descend| function applies a function to all children of a node, then reconstructs a new result using those results. It is a useful function to have, and often is a better choice than top-down traversals, as it preserves the order you would require, but makes more things explicit.


\subsection{Folds}

Traditionally in Haskell a fold replaces each constructor with an alternative. To define a complete fold on a data type, each constructor must be represented, and there is no obvious library function to abstract over this process. A more useful fold for a library such as this would be to allow a default operation. To do this we have:

\begin{code}
fold :: Play alpha => ([r] -> t) -> (alpha -> t -> r) -> alpha -> r
\end{code}

Now lets imagine that programmers are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.

\begin{code}
depth :: Expr -> Int
depth = fold (foldr max 0) $ const (+1)
\end{code}

Our |fold| function takes two functions, one which combines a list of values representing each child, and one which generates a new value given the value for the children and this particular node. In the above example we have used |foldr max 0| to combine all the children -- |maximum| is inappropriate, as |maximum [] = {-"\bot"-}|. The second function |const (+1)| simply adds one to the previous depth.


\subsection{EverythingContext}

The final operation in the library is a curious one -- we have not seen it referenced in any other library, even in those which attempt to include all variations \cite{replib}. However, if the user requires this particular function, they really do need it -- faking it from other operations requires a lot of monadic complexity. This function was actually contributed by a user, which we feel enhances our claim that average users can construct their own operations upon our framework.

Imagine that you wish to change the value of one literal by one, either increasing or decreasing. This particular operation could be useful for mutation testing. To do this we require the function:

\begin{code}
everythingContext :: Play alpha => alpha -> [(alpha, alpha -> alpha)]
\end{code}

This function returns two lists, one of which is the list as would be returned by everything. The other is the function which would replace the hole which the given expression was removed from. It has the properties:

\begin{code}
forall x `o` everything x == map fst (everythingContext x)
forall x `o` all (== x) [b a | (a,b) <- everythingContext x]
\end{code}

Now we are in a situation to write our function:

\begin{code}
mutants :: Expr -> [Expr]
mutants x =  [gen (Val j)
             | (Val i, gen) <- everythingContext x
             , j <- [i-1, i+1]]
\end{code}


\subsection{Summary}

\begin{figure}
\begin{code}
module Data.Generics.Play where

class Play alpha where
    descend            :: (alpha -> alpha) -> alpha -> alpha
    descendM           :: Monad m => (alpha -> m alpha) -> alpha -> m alpha
    everything         :: alpha -> [alpha]
    everythingContext  :: alpha -> [(alpha, alpha -> alpha)]
    fold               :: ([r] -> t) -> (alpha -> t -> r) -> alpha -> r
    rewrite            :: (alpha -> Maybe alpha) -> alpha -> alpha
    rewriteM           :: Monad m  => (alpha -> m (Maybe alpha))
                                   -> alpha -> m alpha
    traverse           :: (alpha -> alpha) -> alpha -> alpha
    traverseM          :: Monad m => (alpha -> m alpha) -> alpha -> m alpha
\end{code}
\caption{All |Play| methods.}
\label{fig:play}
\end{figure}

We present all our methods in Figure \ref{fig:play}, including several monadic variants. We consider these methods encapsulate most of the common operations. In our experience, the most common operations are |everything| and |traverse|, with |traverseM| being the next most common.


\section{Implementing Play}

Requiring each class to implement nine separate methods would be overly arduous. Instead we implement all of these operations on top of just a single method:

\begin{code}
replaceChildren :: Play alpha => alpha -> ([alpha], [alpha] -> alpha)
replaceChildren x = (children,generate)
\end{code}

Given |x|, the function |replaceChildren| will return a tuple comprising of: |children| - all the children of the same type; |generate| - a function to generate a new value with a different set of children. The caller of |generate| must ensure that the length of the list given to it is the same as the length of |children|. The implementor must ensure two conditions:

\begin{code}
forall x `o` x == generate children
    where (children,generate) = replaceChildren x
\end{code}

Firstly, generating a new value using the existing children must give the same value back.

\begin{code}
forall x ys `o`  length ys == length children =>
                 fst (replaceChildren (generate ys)) == ys
    where (children,generate) = replaceChildren
\end{code}

Secondly, after inserting a new set of children, getting those children must return them back.


\subsection{Operations in terms of |replaceChildren|}

Defining operations in terms of |replaceChildren| is easy, we implement the four most common as an example. None is more than a handful of lines long, and none has great deep complexity:

\begin{code}
everything :: Play alpha => alpha -> [alpha]
everything x = x : concatMap everything $ fst $ replaceChildren x

traverse :: Play alpha => (alpha -> alpha) -> alpha -> alpha
traverse f x = f $ generate $ map (traverse f) current
    where (current, generate) = replaceChildren x

traverseM :: (Monad m, Play alpha) => (alpha -> m alpha) -> alpha -> m alpha
traverseM f x = mapM (traverseM f) current >>= f . generate
    where (current, generate) = replaceChildren x

descend :: Play alpha => (alpha -> alpha) -> alpha -> alpha
descend f x = generate $ map f current
    where (current, generate) = replaceChildren x
\end{code}

The common pattern is to call replace children, then perform some action on the current children, before combining them back. Writing additional traversals with different properties can be done ni a simple manner. The |everything| function may be optimised further -- something we return to in \S0.

\subsection{Writing |Play| instances}

The distinguishing feature of our libraries is that the children are defined in terms of their type -- while this makes the traversals and queries simpler, it does mean that the instance definition is dependent on the types of the constructors. While in some generics libraries it is trivial to write the instances, in our case it is more challenging. This is not of a big concern -- we have developed automated approaches to deriving these libraries within the \textsc{Derive} tool. By optionally making use of Multi-Parameter Type Classes we are able to eliminate some of this complexity, see \S0.

\begin{figure}
\begin{code}
instance Play Expr where
    replaceChildren (Neg  a    )  = ([a]    , \[a']     -> Neg  a'     )
    replaceChildren (Add  a b  )  = ([a,b]  , \[a',b']  -> Add  a' b'  )
    replaceChildren (Sub  a b  )  = ([a,b]  , \[a',b']  -> Sub  a' b'  )
    replaceChildren (Mul  a b  )  = ([a,b]  , \[a',b']  -> Mul  a' b'  )
    replaceChildren (Div  a b  )  = ([a,b]  , \[a',b']  -> Div  a' b'  )
    replaceChildren _             = ([]     , \[]       -> x           )
\end{code}
\caption{Instance of |Play| for |Expr|.}
\label{fig:play_expr}
\end{figure}

We construct a |Play| instance for the |Expr| type in Figure \ref{fig:play_expr}. The pattern of the instance can be seen easily. The default clause has no children of type |Expr|, meaning the leaves have been reached.

\subsection{Derivation Rules}

In order to model the derivation of an instance, it is necessary to have a model of the types that are being manipulated:

\begin{code}
type Name  = String
type Var   = String

data Data  = Data Name [Var] [Ctor]
data Ctor  = Ctor Name [Type]
data Type  = TyPrim | TyVar Var | TyApp Data [Type]
\end{code}

When writing a |Play| instance for a particular data type, we can consider this particular type to be the target. We can define how to produce a function for each |Data| type that is used, using the |_D| function:

\begin{code}
_D (Data name vars ctors) = unwords $
    ['d':name] ++ vars ++ ["x ="]
    ["case x of {"] ++
        separate ";" (map _C ctors) ++
    ["}"]

_C (Ctor name typs) =
    [name] ++ vars ++ [" -> "] ++
    ["unit"] ++ [name] ++
    separate "<>" (zipWith (:) vars (map _T typs)) ++
    where vars = ['v':show i | i <- [1..length typs]]

_T (TyPrim       ) = ["unit"]
_T (TyVar  v     ) = [v]
_T (TyApp  d ts  )
    | isTarget d  = ["target"]
    | otherwise   = ['d':dataName d] ++ map _T ts

separate sep xs = concat $ intersperse [sep] xs
\end{code}

Using this derivation, the |Expr| type comes out as:

\begin{code}
dExpr x = case x of
    Val v1     -> unit Val  <> unit v1
    Var v1     -> unit Val  <> dList unit v1
    Neg v1     -> unit Neg  <> target v1
    Add v1 v2  -> unit Add  <> target v1 <> target v2
    Sub v1 v2  -> unit Sub  <> target v1 <> target v2
    Mul v1 v2  -> unit Mul  <> target v1 <> target v2
    Div v1 v2  -> unit Div  <> target v1 <> target v2

dList a x = case x of
    []         -> unit []
    (:) v1 v2  -> unit (:) <> a v1 <> dList a v2
\end{code}

This now provides sufficient information for use to define the |replaceChildren| in several ways. If we are willing to limit ourselves to target types which have no type arguments. The simplest way is to define:

\begin{code}
instance Play Expr where
    replaceChildren x = (getChildren x, setChildren x)
\end{code}


\subsubsection{|getChildren|}

Now we can define |getChildren| as:

\begin{code}
getChildren x = dExpr x

unit = const []
target = (:[])
(<>) = (++)
\end{code}

From these definitions we can do some reasoning. For example, |dList| is actually equivalent to |concatMap|. From this property, we can see that |concatMap (const [])| is equivalent to |const []|.

\subsubsection{|setChildren|}

We can equally define |setChildren| as:

\begin{code}
setChildren x = value (dExpr x)

type Cont t = [alpha] -> (t,[alpha])

unit :: t -> Cont t
unit x ns = (x,ns)

target :: alpha -> Cont alpha
target x (n:ns) = (n,ns)

value :: Cont t -> [alpha] -> t
value c ns = fst $ c ns

(<>) :: Cont (a->b) -> Cont a -> Cont b
(<>) a b ns1 = let (a',ns2) = a ns1
                   (b',ns3) = b ns2
               in  (a' b',ns3)
\end{code}

Of course, all these tuples are very bad for the soul, and should be removed with continuation passing style:

\begin{code}
type Cont t = [alpha] -> (t -> [alpha] -> r) -> r

unit x ns c = c x ns
target x (n:ns) c = c n ns
value c ns = c ns const

(<>) a b ns c =  a ns $ \a' ns ->
                 b ns $ \b' ns ->
                 c (a' b') ns
\end{code}

\subsection{Using Derive}

Applying the presented derivation rules is quite time consuming, and is itself a form of boilerplate -- albeit one specific for each type. The DrIFT tool is well known for defining instances which can be constructed purely from the information contained in type definition. However, there are limitations to the DrIFT tool -- it is unable to operate within the presence of certain Haskell extensions, and requires a separate pre-processing stage on all compilers.

As a separate project, we have developed the \derive{} tool \ref{derive}, in collaboration with Stefan O'Rear. We have extended \derive{} to allow seamless derivation of the |Play| instance. The tool is based on Template Haskell \ref{template_haskell}, but allows Haskell code to be generated which can be appended to the current file.

Taking an example:

\begin{code}
data Term  =  Name String
           |  Apply Term [Term]
              deriving ( {-! \textsf{Play} !-} )
\end{code}

When running the \derive{} tool over this file, the generated code is:

\begin{code}
instance Play Term where
    replaceChildren (Name x1) =
        ([], \_ -> Name x1)

    replaceChildren (Apply x1 x2) =
        (x1:x2, \(n:ns) -> Apply n ns)
\end{code}

This code follows from the definition, but \derive{} has special mechanisms to optimise out redundant patterns to produce cleaner code.

If the user of \derive{} wishes, they can automatically invoke the derivation at compile time using Template Haskell as supported by GHC. This can be acheived with the following command:

\begin{code}
$( derive makePlay {-"\;{}^{\prime\prime}"-}Term)
\end{code}

This allows the user to not worry about separate pre-processing.


\section{Multi-type Queries and Traversals}

We have introduced |Play| which operates on values of type |Expr|. Now let us imagine that our |Expr| type is merely the expression type in a language with statements:

\begin{code}
data Stmt  =  Assign String Expr
           |  Sequence [Stmt]
           |  If Expr Stmt Stmt
           |  While Expr Stmt
\end{code}

We can define a |Play| instance for |Stmt|, and perform queries and traversals upon it. However, consider the task of extracting all literals from within a |Stmt|. This is not possible with |Play|, so we need to go further.

This general form can be seen as operating on items of type |alpha|, but starting an item of type |beta|. Typically the type |beta| will be a container of |alpha|. We can extend our operations by specifying how to find the |alpha|'s within the |beta|'s, and then perform the standard Play operations upon the |alpha|. In the above example, our |alpha| would be |Expr|, and our |beta| would be |Stmt|.

We first introduce |PlayOn|, which requires an explicit function to move between the |alpha| and |beta|. Next we make use of MPTC's to generalise this function into a type class, named |PlayEx|.

\subsection{PlayOn}

In order to define operations such as |everythingOn|, we require an explicit notion of how to move from the containing type to the contained type. We call this operation |replaceType|.

\begin{code}
type ReplaceType beta alpha = beta -> ([alpha], [alpha] -> beta)
replaceType :: ReplaceType beta alpha
\end{code}

The semantics of |replaceType| are that starting from |beta|, the function should return the highest children in the tree of type |alpha|. This particular requirement means that if |alpha == beta| then:

\begin{code}
replaceType x = ([x], [x'] -> x')
\end{code}

We can now define |everythingOn| and |traverseOn| which take an explicit |replaceType| function:

\begin{code}
everythingOn :: Play to => ReplaceType beta alpha -> beta -> [alpha]
everythingOn replaceType x =
    concatMap everything $ fst $ replaceType x

traverseOn ::  Play to => ReplaceType beta alpha ->
               (alpha -> alpha) -> beta -> beta
traverseOn replaceType f x =
    generate $ map (traverse f) current
    where (current, generate) = replaceType x
\end{code}

We note that these operations are very similar to the original |everything| and |traverse|, and perform one layer of traversal -- using the original functions once the correct type has been reached.

Passing this extra |replaceType| argument is a little tedious, a much better approach would be to encapsulate this in a type class, and have it passed as a dictionary argument. Alas this requires MPTC's, which we wish to avoid just slightly longer.

By making a simplifying assumption, we are able to achieve slightly more elegant code, abstracting away the |replaceType| argument. Take for example the Yhc.Core library, part of the York Haskell Compiler (Yhc), which makes use of |Play|. In this library, the central types, along with which types they include, are:

\begin{code}
data Core = Core String [String] [CoreData] [CoreFunc]

data CoreFunc = CoreFunc String String CoreExpr

data CoreExpr  =  CoreVar   String
               |  CoreApp   CoreExpr  [CoreExpr]
               |  CoreCase  CoreExpr  [(CoreExpr, CoreExpr)]
               |  CoreLet   [(CoreVarName, CoreExpr)] CoreExpr
               |  ...
\end{code}

Most boilerplate operations to be written are done on the |CoreExpr| type, however it is often convenient to start from one of the other types. Take for example the |coreSimplify| operation -- it simplifies expressions, but may be called upon one individual expression, a function, or a program. If we are willing to freeze the type of |alpha| as |CoreExpr| we can write a class:

\begin{code}
class  PlayExpr beta where
       replaceTypeExpr :: ReplaceType beta CoreExpr

everythingExpr = everythingOn replaceTypeExpr
traverseExpr = everythingOn replaceTypeExpr

instance PlayExpr Core where ...
instance PlayExpr CoreFunc where ...
instance PlayExpr CoreExpr where ...
instance PlayExpr beta => PlayExpr [beta] where ...
\end{code}

This has been used extensively in the Yhc compiler. Since the Yhc compiler does not support multi-parameter type classes, and is hoped to be bootstrapping shortly, this rules out MPTC.

\subsection{PlayEx}

If we are willing to make use of the MPTC extension, we may introduce a class |PlayEx| which includes the |replaceType| function.

\begin{code}
class  PlayEx beta alpha where
       replaceType :: ReplaceType beta alpha
\end{code}

This takes us outside the realm of Haskell 98, however we feel that the MPTC is conceptually simple to understand. We have not required functional dependencies, and our code is all able to execute on both Hugs and GHC.

We can now implement |everythingEx| and |traverseEx| in terms of their |On| counterparts:

\begin{code}
traverseEx :: PlayEx beta to => (alpha -> alpha) -> beta -> beta
traverseEx = traverseOn replaceType

everythingEx :: PlayEx beta alpha => beta -> [alpha]
everythingEx = everythingOn replaceType
\end{code}

We now present two examples from the original section, but implemented using |PlayEx|, so they would work if given either an |Expr| or a |Stmt|.

\begin{code}
variables :: PlayEx beta Expr => beta -> [String]
variables x = [y | Var y <- everythingEx x]
\end{code}

Note that the only change to the a actual code is the addition of the |Ex| suffix to |everything|. The type signature has changed so that instead of |Expr -> [String]| we have replaced |Expr| with |PlayEx beta Expr => beta|. Another way of looking at this is instead of requiring the input to be an |Expr|, we merely require that from the input we know how to reach an |Expr|.

\begin{code}
simplify x = traverseEx f x
    where  f (Sub x y)  = Add x (Neg y)
           f x          = x
\end{code}

In a similar manner to before, we simply add an |Ex| at the end. The actual code changes are minimal.

\section{Implementing PlayEx}

The complicating feature of |replaceType| is that when defining |PlayEx| where |alpha == beta| the program does not descend to the children, but simply returns this particular node. This ``same type'' restriction can be captured either using the type system, or using |Typeable|. We present three methods for defining a |PlayEx| instance -- offering a trade-off between performance, compatibility and volume of code. The first method, Manual, requires $O(n^2)$ instances but is the highest performance and fewest extensions -- and can be automated. The second method makes use of the |Typeable| class providing reasonable speed with $O(n)$ instances and no further Haskell extensions. The final method makes use of the |Data| class, providing fully automatic instances on GHC, but requiring the use of rank-2 types, and performing the slowest.

The |PlayEx| is a nice abstract, which allows any of the three methods to be used underneath. This flexibility allows the user to start with the simplest instance scheme available to them -- and change the instances to gain increased performance and compatibility. All the schemes also provide a simplified mechanism for writing |Play| instances.

\subsection{Manual instances}

This requires $O(n^2)$ but gives the highest performance. Like before these can be automatically generated, and you can move to these instances afterwards. These instances are not quite mechanical, but are certainly easier than |Play|.

\begin{code}
instance PlayOne NExpr where
    playOne x =
        case x of
            NNeg  a    -> play NNeg |* a
            NAdd  a b  -> play NAdd |* a |* b
            NSub  a b  -> play NSub |* a |* b
            NMul  a b  -> play NMul |* a |* b
            NDiv  a b  -> play NDiv |* a |* b
            _          -> play x
\end{code}

There are 5 combinators available, go through all of them.

The advantage of this is that you don't need to search into deep corners.


\subsection{In terms of |Typeable|}

Writing |PlayEx| can be done following a similar scheme to |Play|. However, the freedom to use multi-parameter type classes can give us a little more freedom. By using overlapping instances, we can use the |/\| combinator:


To define the PlayEx class, there are three combinatiors that can be used. These automate much of the definition:

\begin{code}
play :: on -> ([with],[with] -> on)
(/\) :: PlayEx item with => ([with], [with] ->
    item -> on) -> item -> ([with], [with] -> on)
(/\!) :: ([with], [with] -> item -> on) ->
    item -> ([with], [with] -> on)
\end{code}

Note, the above are presented with type signatures for completeness. They are intended to be used mechanically, without excessive thought.

To define a PlayEx instance for the Expr type introduced earlier:

\begin{code}
instance PlayEx Expr a where
    replaceChildrenEx x =
        case x of
            Val a -> play Val /\! a
            Add a b -> play Add /\ a /\ b
            Sub a b -> play Sub /\ a /\ b
            ...
            Neg a -> play Neg /\ a
\end{code}

The definition follows mechanically. The only choice a user makes is whether to use the |(/\)| operator (which recurses into the child on the right), or the |(/\!)| operator, which doesn't. For example, here we have decided not to traverse inside the Int of Val. This can be changed, and would require a PlayEx instance for Int.

If using this style of definition, a special instance must be defined for the self case:

instance PlayEx Expr Expr where
    replaceChildrenEx = playSelf

Unfortunately this requires undecidable instances. A Play instance still needs to be written for each definition.


\subsection{In terms of |Data|}

We are able to make use of the existing |Data| and |Typeable| instances provided by the SYB approach to define Play classes. To have access to all |Play| and |PlayEx| instances simply:

\begin{code}
import Data.Generics.PlayData
import Data.Generics

data Expr ... deriving (Typeable, Data)
\end{code}

The disadvantages of this are the lack of type safety - you can now do entirely meaningless operations, which the earlier definitions would have spotted as being an error. This code will also only work where Data.Generics is supported, namely GHC at the present time. The clear advantage is that there is almost no work to creating Play instances.

\begin{figure}
\begin{code}
repChildren  :: (Data alpha, Play beta, Typeable alpha, Typeable beta)
             => alpha -> ([beta],[beta] -> alpha)
repChildren item = (collect, generate)
    where
        collect = concat $ gmapQ getChildrenEx item

        generate xs = evalState (gmapM f item) xs
        f x = do  let (col,gen) = replaceChildrenEx x
                  (as,bs) <- liftM (splitAt $ length col) get
                  put bs
                  return $ gen as
\end{code}
\caption{Code for |Play| in terms of |Data|.}
\label{fig:playdata}
\end{figure}

How do we implement these classes? The fundamental operation is given in Figure \ref{fig:playdata}. The outer class uses the same method as given in the |Typeable| derivation, and if the program does need to descend, then this is done by |repChildren|. The operation to get the children can be done using |gmapQ|. The operation to replace the children is more complex, requiring a state monad to keep track of the items to insert.

This instance is not optimised for speed, in particular the |splitAt|/|length| portion will take traverse the list more than is necessary. We discuss how to come up with an optimised version in \S0.


\section{Properties}

This section discusses various properties that hold. Some of these could be turned into GHC rules, but this has not been done.

\subsection{General Properties}

\begin{code}
descend id == id
traverse id == id
rewrite (const Nothing) == id

descendM return == return
rewriteM (return . const Nothing) == return
traverseM return == return

fold _ const = id

everything . traverse f == map (traverse f) . everything
\end{code}

\subsection{List Properties}

A list is defined inductively as |data [alpha] = [] || alpha : [alpha]|. We can therefore define a |Play| instance as:

\begin{code}
instance Play [alpha] where
    replaceChildren []      = ([]    , const []       )
    replaceChildren (x:xs)  = ([xs]  , \[xs] -> x:xs  )
\end{code}

Now some common list operations can be represented as traversals:

\begin{code}
everything == tails
\end{code}



\section{Coding Benchmarks}

In this section we compare specific examples of operations using the |Play| framework versus other frameworks. In particular the alternatives we focus on are Scrap Your Boilerplate and Compos. We start by using the single-type examples from Compos, then move on to the multi-type traversals. We then move on to the ``Paradise Benchmark'' from SYB. In all cases the Compos, SYB and Play functions are denoted by a preceding module name qualified. In some instances, a single operate function can be written the same in both SYB and Play -- where this is possible we have done so. Where possible, type signatures have been left absent -- these are a form of boilerplate that Haskell already deals with.

We explicitly do not focus on the execution time for these operations, instead leaving this to the next section.

\subsection{Simple Examples from This Paper}

Here we simply give variations for the code shown before. Since our existing coding is so short, we have replicated it.

\subsubsection{|variables|}

\begin{code}
Play.variables x = [y | NVar y <- everything x]

SYB.variables = everything (++) ([] `mkQ` f)
    where  f (NVar y)  = [y]
           f _         = []

Comp.variables :: Expr a -> [String]
Comp.variables x = case x of
    Var y -> [y]
    _ -> composOpFold [] (++) Comp.variables x
\end{code}

In this example only Compos has been given a type signature, this is because in the other examples one can be automatically inferred -- but not for Compos. We note that list comprehensions are wonderful for queries.

\subsubsection{|zeroCount|}

\begin{code}
Play.zeroCount x = length [() | Div _ (Val 0) <- everything x]

SYB.zeroCount = SYB.everything (+) (0 `mkQ` f)
    where  f (Div _ (Val 0))  = 1
           f _                  = 0

Comp.zeroCount :: Expr a -> Int
Comp.zeroCount x = case x of
    Div y (Val 0) -> 1 + zeroCount y
    _ -> composOpFold 0 (+) zeroCount x
\end{code}

Note here that the returning of a list of |()| is not as neat as it could be. Also, note the continuation in the Compos solution -- if this was missed (which is easy) it wouldn't work. This shows that manually continuing the traversal could be dangerous in some cases.

\subsubsection{|simplify|}

\begin{code}
simp (Sub x y)           = Add x (Neg y)
simp (Add x y) | x == y  = Mul (Val 2) x
simp x                   = x

Play.simplify = traverse simp

SYB.simplify = everywhere (mkT simp)

Comp.simplify :: Expr a -> Expr a
Comp.simplify x = case x of
    Sub  a b -> Add (simplify a) (Neg (simplify b))
    Add  a b -> case  (simplify a, simplify b) of
                      (a',b')  | a' == b'   -> Mul (Val 2) a'
                               | otherwise  -> Add a' b'
    _ -> composOp simplify x
\end{code}

Note here that this situation really calls out for a bottom-up traversal, which we provide, but Compos does not.


\subsection{Multi-type Compos Examples}

\begin{figure}
\begin{code}
data Stm  =  SDecl    Typ Var
          |  SAss     Var Exp
          |  SBlock   [Stm]
          |  SReturn  Exp

data Exp  =  EStm  Stm
          |  EAdd  Exp Exp
          |  EVar  Var
          |  EInt  Int

data Var  =  V String

data Typ  =  T_int | T_float
\end{code}
\caption{Data type from Compos.}
\label{fig:compos}
\end{figure}

The types manipulated by Section 4 are given in Figure \ref{fig:compos}. The first thing done by the Compos paper is to translate this into a GADT, which destroys abstraction. If a data structure representing a program was also defined, then this would have to be merged into the single GADT. Play on the other hand accepts the definition as supplied.

We have not discussed the |warnAssign| function from this paper, as it could be implemented much more neatly as a query.

\subsubsection{The |rename| function}

\begin{code} % compos
ren (V x) = V ("_" ++ x)

Play.rename = traverseEx ren

SYB.rename = everywhere (mkT ren)

Comp.rename :: Tree c -> Tree c
Comp.rename t = case t of
    V x -> V ("_" ++ x)
    _   -> composOp rename t
\end{code}

The first thing to note is the Play function is shorter, there is only one constructor in type |Var|. In contrast Compos has merged all constructors into one GADT, and can not benefit from this. The Compos function works over all trees, including those based on |Typ|, which is meaningless, since types do not contain variables. The Play class only operates on |Exp| and |Stm| types.


\subsubsection{The |symbols| function}

\begin{code}
Play.symbols x = [(v,t) | NSDecl t v <- everythingEx x]

SYB.symbols = everything (++) ([] `mkQ` f)
    where  f (NSDecl t v)  = [(v,t)]
           f _             = []

Comp.symbols :: Tree c -> [(Tree Var, Tree Typ)]
Comp.symbols x = case x of
    SDecl typ var -> [(var,typ)]
    _ -> composOpMonoid symbols t
\end{code}

Here the Compos function does a traversal of the tree, however again the Play class simply extracts the right bits. This example is almost identical to the previous |warnAssign| using Play, however the Compos approach introduces distinctions by requiring a more ordered approach to traversal.


\subsubsection{The |constFold| function}

\begin{code}
optimise (EAdd (EInt n) (EInt m)) = EInt (n+m)
optimise x = x

Play.constFold = traverseEx optimise

SYB.constFold = everywhere (mkT optimise)

Comp.constFold :: Tree c -> Tree c
Comp.constFold e = case e of
    EAdd x y -> case  (f x, f y) of
                      (CEInt n, CEInt m) -> CEInt (n+m)
                      (x',y') -> CEAdd x' y'
    _ -> composOp constFold e
\end{code}

The constant folding operation is a bottom-up traversal, requiring sub expressions to have been replaced before they are examined. Unfortunately Compos only supports top-down traversals, requiring the user to manually do a small traversal in the middle. Play and SYB both support bottom-up traversals, so this works fine.


\subsection{The Paradise Benchmark}

\begin{figure}
\begin{code}
type Manager  = Employee
type Name     = String
type Address  = String

data Company   = C [Dept]
data Dept      = D Name Manager [Unit]
data Unit      = PU Employee | DU Dept
data Employee  = E Person Salary
data Person    = P Name Address
data Salary    = S Integer
\end{code}
\caption{Paradise Benchmark data structure.}
\label{fig:paradise}
\end{figure}

The Paradise benchmark was introduced in SYB \ref{syb}. The data type is shown in Figure \ref{fig:paradise}. The idea is that this data type represents an XML file, and a Haskell program is being written to perform various operations over it. The Compos paper includes an encoding into a GADT, with tag types for each of the different types.

We have made one alteration to the data type -- |Salary| is no longer of type |Float| but of type |Integer|. In various experiments we found that the floating point numbers could not be guaranteed to have the required accuracy -- making different operations return different results, despite being theoretically the same. This change is of no consequence to the boilerplate code -- although does remind us that storing your salary in a non-exact manner is probably not a great idea!

\subsubsection{The |increase| function}

The first function discussed in the SYB paper is |increase|. This function increases every item of type |Salary| by a given percentage. In order to fit with our modified |Salary| data type, we have chosen to increase all salaries by |k|.

\begin{code}
incS :: Integer -> Salary -> Salary
incS k (S s) = S (s + k)

Play.increase k = traverseEx (incS k)

SYB.increase k = everywhere (mkT (incS k))

Comp.increase :: Integer -> Tree c -> Tree c
Comp.increase k c = case c of
    S s -> S (s + k)
    _ -> composOp (increase k) c
\end{code}

The effect of Compos to transform all constructors into the same set means that instead of just matching on |S|, all constructors must be examined.

\subsubsection{The |incrOne| function}

The |incrOne| function performs the same operation as |increase|, but only within a named department. We are able to reuse the |increase| function from the previous section in all cases.

\begin{code}
Play.incrOne n k = descendEx f
    where f x@(ND name _ _)  | name == n  = increase k x
                             | otherwise  = descend f x

SYB.incrOne n k a  | isDept n a  = increase k a
                   | otherwise   = gmapT (incrOne n k) a
    where  isDept n = False `mkQ` isDeptD n
           isDeptD n (D n2 _ _) = n == n2

Comp.incrOne :: Name -> Float -> Tree c -> Tree c
Comp.incrOne d k c = case c of
    D n _ _ | n == d -> Comp.increase k c
    _ -> composOp (incrOne d k) c
\end{code}

Here SYB has grown substantially more complex, to accommodate the invariant, requiring two different utility functions. Compos still retains the same structure as before, requiring a case to distinguish between the types of constructor. A simple |traverse| would not suffice here as if a department is contained within a department of the same name, then the employees would have their salaries increased twice.

\subsubsection{The |salaryBill| function}

The final function is one which sums all the salaries.

\begin{code}
Play.salaryBill x = sum [x | S x <- everythingEx x]

SYB.salaryBill = everything (+) (0 `mkQ` billS)
   where billS (S f) = f

Comp.salaryBill :: Tree c -> Integer
Comp.salaryBill c = case c of
    S s -> s
    _ -> composOpFold 0 (+) Comp.salaryBill c
\end{code}

Here the Play instance wins by being able to use a list comprehension to select the salary value out of a Salary object. The Play class is the only one that is able to use the standard Haskell |sum| function, not requiring an explicit fold to be performed. This solution is nice in that it is a very specification orientated view of the problem. Take all the salaries, get their value, and sum them.


\section{Implementation Speed}

Something that has been neglected in previous papers on boilerplate is the performance aspects. The first SYB paper gives the quotation ``Our benchmarks show that generic programs are reasonably efficient'', and gives a slow down of 3.5 times for the salary increase program. We choose to benchmark on all the examples shown in the previous section. Our benchmark uses the code as presented in that section. We also benchmark against a hand-coded operation with no boilerplate. The four |Play| derivations are provided by:

\begin{description}
\item[Hand Coded:] These are |Play| and |PlayEx| instances written by hand. We have chosen not to use continuation-passing to implement these instances, as it quickly becomes deeply complex. We have implemented both |getChildren| and |replaceChildren|.
\item[Manual:] These instances use the manual combinators, defined a required.
\item[Typeable:] These instances use the standard typeable combinators.
\item[Data:] These instances use the SYB |Data| instances directly.
\end{description}

In many cases there are several equivalent |Play| methods that could be used, we choose only the simplest.

First all data structures used have 100 particular values randomly generated and saved. In order to ensure a fair comparison, we define one data structure which is the same as the original, and one which is a GADT encoding. All operations take these original data structures, transform them into the appropriate structure, apply the operation and then unwrap them. We measure all results relative to the time taken for a raw transformation as 1. We compiled all programs with -O2.

The results are presented in Table n, and graphs in Figure n and m. This shows that using well tuned instances, Compos is the same speed as Play. Using Data instances, we are still able to outperform Scrap Your Boilerplate -- for whom Data instances are perfect! At first glance, these results may well seem surprising, given the intermediate list of children created and examined at each stage. We first discuss the manual Play instances, and how they are optimized -- primarily by using continuations. We then focus on our optimization of |everything|, again using continuation passing -- and additionally using some |foldr|/|build| fusion properties. Finally we turn to our |PlayData| module, and how we are able to outperform SYB using their instances underneath.

We suspect there are further places for improvement:

\begin{itemize}
\item Continuation passing style may eliminate tuple construction and consumption.
\item List fusion may be able to eliminate some of the lists in |replaceChildren|.
\end{itemize}

\subsection{PlayManual continuation passing}


\subsection{Optimising |everything|}

Our initial |everything| implementation was presented as:

\begin{code}
everything :: Play on => on -> [on]
everything x = x : concatMap everything $ getChildren x
\end{code}

The disadvantage of this code is that the |concatMap| constructs and consumes the list at every level, requiring one reconstruction per level of depth in the data structure. We can fix this by using continuations:

\begin{code}
everything x = f x []
    where  f :: Play on => on -> [on] -> [on]
           f x rest = x : concatCont (map f $ getChildren x) rest

concatCont []     rest  =  rest
concatCont (x:xs) rest  =  x (concatCont xs rest)
\end{code}

Now we only perform one reconstruction per level. However, we can do better still using GHC's list fusion. The user of everything is likely to be a good consumer, if it is a list comprehension. We can now make |concatCont| a good consumer:

\begin{code}
concatCont xs rest = foldr ($) rest xs
\end{code}

Now we can also make |f| a good producer using |build|:

\begin{code}
everything :: Play on => on -> [on]
everything x = build (f x)
    where
    f :: Play on => on -> (on -> res -> res) -> res -> res
    f x cons nil = x `cons`
        concatCont (map (flip f cons) $ getChildren x) nil
\end{code}


\subsection{Optimising |PlayData|}

The |PlayData| instance is an area of the library we are particularly proud of -- being able to use the existing SYB framework which is already built into the GHC compiler makes boilerplate code much easier to write. Managing to both layer |PlayData| over the |Data| instances, and perform better is not something we initially believed to be possible.

The first optimisation was to move from generating the two elements on the |replaceChildren| tuple separately, to doing it as one task. This means that it is no longer possible to use |gmapM|, but instead we must use |gfoldl|. This reduction means that each data constructor gets examined fewer times, and our use of the state monad can be eliminated.

The second optimisation is to translate to a basic continuation passing style in some places, as per |PlayManual|.

Note the use of case instead of where to make tuples faster.

With all these optimisations in place we perform much the same operations as SYB, but have the overhead of list creation at each step. We are able to push this approach to within about 15\% of the speed of SYB operations.

The next optimisation relies on the extra information present in |Play| operations -- namely the target type. For SYB, the target type could be any node on the graph, while for Play it will have a known type. This means as a node is reached, if there can be no nodes of the target type beneath it, the search does not need to continue. Computing which types are containers for the target type can be done relatively easily with the SYB framework:

\begin{code}
data DataBox = forall a . (Typeable a, Data a) => DataBox a

contains :: (Data a, Typeable a) => a -> [DataBox]
contains x = if isAlgType dtyp then concatMap f ctrs else []
    where
        f ctr = gmapQ DataBox (asTypeOf (fromConstr ctr) x)
        ctrs = dataTypeConstrs dtyp
        dtyp = dataTypeOf x
\end{code}

The |contains| function takes a value which is does not examine, and is always |undefined| in this context. It then returns all fields, and |typeOf| can be performed on each one.

This list of types and their containers can have its transitive closure taken, and all types can be divided into 3 sets -- the singleton set containing the target, the set of types which may contain the target, and the set of types which do not. When examining a node, if its type is a member of the set which does not contain the target, we can prune the search at this point.

This trick is surprisingly effective. Take for example an operation over |Bool| on the value |(True,"Haskell")|. The SYB approach will find 16 nodes, Play will only touch 3 nodes -- as soon as it notices the |String| it will stop. By increasing the length of the string, SYB performs increasingly more work -- Play does not.

We compute the good set for each type only once by using a CAF inside the class to store it. The cost of computing the set is relatively small, and in some larger traversals will pay off during the initial traversal.


\section{Related Work}

This library is intended to be a way to remove the boilerplate for Haskell programs, and it is certainly not the first library to attempt this. Below we compare against some of the more popular alternatives. We have deliberately focused on functional programming -- often generic approaches feel the need to compare to the object-orientated Visitor pattern -- we see it as a different approach for different people.

\subsection{SYB}

Perhaps the most popular boilerplate removal system in Haskell is the SYB approach. One of the reasons for this success is that integration with the GHC compiler, lowering the barrier to use. We have compared directly against traversals written in SYB in the previous section, and also covered how to implement Play in terms of SYB.

\todo{image here}

Both traversals are based on the idea of finding the immediate children of a node. The difference is that Play considers a child to be one of the same type, which may not be immediately below the node. In contrast SYB considers all the immediate children. The above diagram shows the difference, where the orange nodes are all of the same type, and those with a black border are considered children.

While the SYB approach is clearly more logical in an untyped language, in a typed language it requires a considerable amount of trickery to get the types correct. The primary SYB traversal function is:

\begin{code}
gfoldl  ::  (forall a b . Data a => c (a -> b) -> a -> c b)
        ->  (forall g . g -> c g)
        ->  a -> c a

replaceChildren :: on -> ([on], [on] -> on)
\end{code}

In the original SYB paper the authors note ``Trying to understand the type of |gfoldl| directly can lead to brain damage.'' When compared to the type of |replaceChildren|, it is easy to see which is simpler at the type level.

\begin{code}
\end{code}

The basic difference between SYB and Play is the choice of the notion of children. It is reasonably easy to see that SYB is more powerful - there are many nodes in the above example that Play cannot reach. However in a typed language this has come at the cost of substantial type based thought. Play on the other hand simplified things with its alternative definition of child.

We do not include support for many of the other generic features in SYB, such as gread/gshow etc, so they are much more powerful.

We are one of the few traversals who do not have the problem that SYB is compiler integrated, but we are not. We are also faster than SYB.

\subsection{Compos}

The Compos approach is newer than SYB, requiring the GADT's extension along with rank-2 types. While the Compos library can operate over GADT's, it is somewhat restricted to them, requiring an existing data structure to be rewritten as a GADT. The conversion from standard Haskell data structures to GADT's presents several problems: they are GHC specific; deriving is not supported on GADT's; they require explicit type signatures. Some of these problems come about as a result of GADT's being a recent addition.

The Compos approach is also harder to write instances for, having no simple instance generation framework, and no automatic derivation tool (although one could be written). The inner |composOp| operator is very powerful, and indeed we have chosen to replicate it in our library as |descend|. In contrast the Compos library is unable to replicate the query to a list, or the bottom-up traversal.

\subsection{Stratego}

If you think that's "easy", why not use the real thing (Stratego)? You lose type-inference, but you don't need those ugly mk constructors.

http://www.acm.org/crossroads/xrds12-3/stratego.html

\subsection{Attribute Grammars}

Yes, those things are really cool. Have you every looked into Attribute Grammars? It's not quite the same, but still related. See: UUAGC and also Wouter Swierstra's excellent article in the Monad Reader: Why Attribute Grammars Matter.

http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem

http://www.haskell.org/tmrwiki/WhyAttributeGrammarsMatter

\subsection{Applicative}

\subsection{From Ralf}

Just a few notes. (i) Hugs *does* support rank-2 polymorpism but it does not implement the type class Data I guess, but perhaps it should. Also there is a small chance that hugs' approach to rank-2 is not exactly identical and would trigger issues with SYB. (ii) If you generally prefer exercising a GP setup such that no rank-2 types surface the program, you could use Strafunski. (iii) In particular, have a look at the "polymorphic symphony" paper that uses first-class polymorphism (as opposed to rank-2) and opaque generic function types to set up a library of generic function combinators. Because it uses data types for generic function types, you get full type inference. (iv) You find an older JLAP paper on my web site developing a simple type system for a Stratego-like formal setup.

\section{Conclusions and Future Work}

\acks

The first author is a PhD student supported by a studentship from the Engineering and Physical Sciences Research Council of the UK. Thanks to Bj\"{o}rn Bringert for feedback on an earlier version of this document, Eric Mertens for various ideas and code snippets and Stefan O'Rear for work on the \textsc{Derive} tool.

\bibliographystyle{plainnat}
\bibliography{play}



\end{document}
