<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <title>Boilerplate Removal with Uniplate</title>
        <style type="text/css">
pre {
    border: 2px solid gray;
    padding: 1px;
    padding-left: 5px;
    margin-left: 10px;
    background-color: #eee;
}

pre.define {
    background-color: #ffb;
    border-color: #cc0;
}

body {
    font-family: sans-serif;
}

h1, h2, h3 {
    font-family: serif;
}

h1 {
    color: rgb(23,54,93);
    border-bottom: 1px solid rgb(79,129,189);
    padding-bottom: 2px;
    font-variant: small-caps;
    text-align: center;
}

a {
    color: rgb(54,95,145);
}

h2 {
    color: rgb(54,95,145);
}

h3 {
    color: rgb(79,129,189);
}
        </style>
    </head>
    <body>

<h1>Boilerplate Removal with Uniplate</h1>

<p style="text-align:right;margin-bottom:25px;">
    by <a href="http://community.haskell.org/~ndm/">Neil Mitchell</a>
</p>

<p style="margin-left:10%;margin-right:10%;margin-bottom:25px;text-align:justify;">
    Generic transformations and queries are often referred to as boilerplate code - they remain relatively similar as the action performed by the code changes, and can often outnumber the actual intent of the code in terms of lines. While other generic traversal schemes have shown how powerful new features can be added to compilers, and how the type system can be manipulated into accepting these operations, this document focuses on a conceptually simpler generic concept. The <i>Uniplate</i> class is introduced, which abstracts over common traversals and queries in a simple manner. A more complete document on the Uniplate class was published at the Haskell Workshop 2007, and is available from the <a href="http://www-users.cs.york.ac.uk/~ndm/uniplate/">project website</a>, along with a video presentation, and the associated thesis chapter.
</p>
<p>
    There have been several attempts at generic traversal/query methods in Haskell. One initial paper was <a href="http://doi.acm.org/10.1145/604174.604179">"Scrap your boilerplate: a practical design pattern for generic programming"</a> (<a href="http://www.cs.vu.nl/boilerplate/tldi03.pdf">free copy</a>) - which I will refer to as SYB. Another mechanism is <a href="http://doi.acm.org/10.1145/1159803.1159834">"A Pattern for Almost Compositional Functions"</a> (<a href="http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf">free copy</a>) - which I refer to as Compos (after the name of their class). A detailed comparison is given in the Uniplate paper.
</p>
<p>
    The principle advantage of the Uniplate class over these two papers is that it requires no type system extensions, compared to rank-2 types for SYB and GADT's for Compos. The simplicity of the types required means that the user is free to concentrate on the operations within the class, without requiring thought as to the type trickery required. The Uniplate pattern has been implemented in <a href="http://haskell.org/haskellwiki/Yhc">Yhc</a> for the Core data type, and in <a href="http://www-users.cs.york.ac.uk/~ndm/catch/">Catch</a> on several data types within the program.
</p>
<p>
    This document proceeds as follows:
</p>
<ol>
    <li>The motivation and use cases for Uniplate</li>
    <li>Extensions to Biplate</li>
    <li>Uniplate and Biplate instances</li>
</ol>
<p>
    The libraries is available through <a href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uniplate">Hackage</a> or darcs:
</p>
<pre>
darcs get --partial <a href="http://community.haskell.org/~ndm/darcs/uniplate">http://community.haskell.org/~ndm/darcs/uniplate</a>
</pre>
<p>
    If you only wish to read a small fraction of this document, can I suggest you pay particular attention to <tt>transform</tt> and <tt>universe</tt> - these are by far the most common traversal patterns.
</p>

<h3>Acknowledgements</h3>

<p>
    Thanks to Bj&ouml;rn Bringert for feedback on an earlier version of this document, Eric Mertens for various ideas and code snippets, and to Matt Naylor and Tom Shackell for helpful discussions.
</p>


<h2>Motivation and Use Cases</h2>

<p>
    The idea behind the Uniplate class is that there exists a data structure, usually with a reasonable number of constructors, which is often transformed or analysed. The usual example of this would be a compiler, which has at its core an expression type. This can be seen as a form of generic programming.
</p>
<p>
    The Uniplate class has the following goals:
</p>
<ul>
    <li>Adding a new constructor should require very few changes</li>
    <li>Traversals should have a minimal amount of boiler plate</li>
    <li>The obvious code should "just work"</li>
    <li>Haskell 98, where possible</li>
    <li>Writing new types of traverals is easy</li>
    <li>The default traversals cover most cases</li>
</ul>
<p>
    The ideas behind the Uniplate class have been used extensively, in both the Yhc compiler and the Catch tool. In Catch there are over 100 traversals using the Uniplate class, showing that the Uniplate class gets extensive use.
</p>


<h2>Using Uniplate</h2>

<p>
    These examples revolve around a small arithmetic language, given here:

</p>
<pre>
import Data.Generics.Uniplate

data Expr = Val Int
          | Add Expr Expr
          | Sub Expr Expr
          | Div Expr Expr
          | Mul Expr Expr
          | Neg Expr
          deriving (Show, Eq)
</pre>
<p>
    Assume that a Uniplate class has already been written; so now <tt>instance Uniplate Expr</tt> is available to us. Some examples are presented, in rough order of increasingly complexity.
</p>

<h3>Checking for division by zero</h3>

<pre class="define">
universe :: Uniplate on => on -> [on]
</pre>
<p>
    If an expression is divided by zero, this causes a runtime error in our language. As part of the compiler, it's nice to give the user a warning message about this. This can be done with the following test:
</p>
<pre>
hasDivZero :: Expr -> Bool
hasDivZero x = not $ null [() | Div _ (Val 0) <- universe x]
</pre>
<p>
    Here the only Uniplate method being used is <tt>universe</tt>. Given a tree, <tt>universe</tt> returns all the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done above. For each division by zero found, any value is created in the list comprehension, and then this is checked to see if anything did match. Returning the count of divide by zero errors is trivial, simply use <tt>length</tt> instead of <tt>not $ null</tt>.  Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error.
</p>
<p>
    <i>Exercise:</i> Write a function to find all literals that occur in an expression, together with their count.
</p>

<h3>Basic optimisation</h3>

<pre class="define">
transform :: Uniplate on => (on -> on) -> on -> on
</pre>
<p>
    If we are negating a literal value, this computation can be performed in advance, so let's write a function to do this.
</p>
<pre>
optimise :: Expr -> Expr
optimise = transform $ \x -> case x of
    Neg (Val i) -> Val (negate i)
    x -> x
</pre>
<p>
    Here the Uniplate method being used is <tt>transform</tt>. This applies the given function to all the children of an expression, before applying it to the parent. This can be thought of as bottom-up traversal of the data structure. The optimise code merely pattern matches on the negation of a literal, and replaces it with the literal.
</p>
<p>
    Now lets add another optimisation into the same pass, just before the <tt>x -> x</tt> line insert:
</p>
<pre>
    Add x y | x == y -> Mul x (Val 2)
</pre>
<p>
    This takes an addition where two terms are equal and changes it into a multiplication, causing the nested expression to be executed only once. This shows that normal Haskell applies, the Uniplate lets you write code as before.
</p>
<p>
    <i>Exercise:</i> Extend the optimisation to so that adding <tt>x</tt> to <tt>Mul x (Val 2)</tt> produces a multiplication by 3.
</p>


<h3>Depth of an expression</h3>

<pre class="define">
para :: Uniplate on => (on -> [res] -> res) -> on -> res
</pre>
<p>
    Now lets imagine that programmers in your language are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.
</p>
<pre>
depth :: Expr -> Int
depth = para (\_ cs -> 1 + maximum (0:cs))
</pre>
<p>
    This function performs a paramorphism (a bit like a fold) over the data structure. The function simply says that for each iteration, add one to the previous depth.  An evaluator for this expression language can also be modelled as a <tt>para</tt>, see inside the example directory to see an implementation.
</p>
<p>
    <i>Exercise:</i> Write a function that counts the maximum depth of addition only.
</p>

<h3>Renumbering literals</h3>

<pre class="define">
transformM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on
</pre>
<p>
    The literal values need to be replaced with a sequence of numbers, each unique. This is unlikely for an arithmetic expression, but consider bound variables in lambda calculus and it starts to become a bit more plausible:
</p>
<pre>
uniqueLits :: Expr -> Expr
uniqueLits x = evalState (transformM f x) [0..]
    where
        f (Val i) = do
            y:ys <- get
            put ys
            return (Val y)
        f x = return x
</pre>
<p>
    Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.
</p>
<p>
    <i>Exercise:</i> Allow each literal to occur only once, when a second occurance is detected, replace that literal with zero.
</p>

<h3>Generating mutants</h3>

<pre class="define">
contexts :: Uniplate on => on -> [(on, on -> on)]
</pre>
<p>
    The person who is inputting the expression thinks they made a mistake, they suspect they got one of the values wrong by plus or minus one. Generate all the expressions they might have written.
</p>
<pre>
mutate :: Expr -> [Expr]
mutate x = concat [[gen $ Val $ i-1, gen $ Val $ i+1]
                  | (Val i, gen) <- contexts x]
</pre>
<p>
   The <tt>transform</tt> function is useful for doing an operation to all nodes in a tree, but sometimes you only want to apply a transformation once. This is less common, but is sometimes required. The idea is that the context provides the information required to recreate the original expression, but with this node altered.
</p>
<p>
    <i>Exercise:</i> Replace one multiplication with addition, if there are no multiplications return the original expression.
</p>


<h3>Using the operations from Biplate</h3>

<p>
    To see various operations being used from the Biplate class, see the Uniplate paper. Typically the operations are just the same as Uniplate, with <tt>Bi</tt> on the end.
</p>
<pre class="define">
universeBi:: Biplate on with => on -> [with]
transformBi :: Biplate on with => (with -> with) -> on -> on
transformBiM :: (Monad m, Biplate on with) => (with -> m with) -> on -> m on
</pre>


<h3>Uniplate and Biplate instances</h3>

<p>
    To define Uniplate and Biplate instances it is sufficient to:
</p>
<ul>
	<li>Use GHC.</li>
	<li>Import the module <tt>Data.Generics.PlateData</tt>.</li>
	<li>Add <tt>deriving (Data,Typeable)</tt> to all data type definitions.</li>
</ul>
<p>
	Alternative ways of implementing Uniplate and Biplate instances are presented in the associated thesis chapter.
</p>


    </body>
</html>
