<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <title>Boilerplate Removal with Uniplate</title>
        <style type="text/css">
pre {
    border: 2px solid gray;
    padding: 1px;
    padding-left: 5px;
    margin-left: 10px;
    background-color: #eee;
}

pre.define {
    background-color: #ffb;
    border-color: #cc0;
}

body {
    font-family: sans-serif;
}

h1, h2, h3 {
    font-family: serif;
}

h1 {
    color: rgb(23,54,93);
    border-bottom: 1px solid rgb(79,129,189);
    padding-bottom: 2px;
    font-variant: small-caps;
    text-align: center;
}

a {
    color: rgb(54,95,145);
}

h2 {
    color: rgb(54,95,145);
}

h3 {
    color: rgb(79,129,189);
}
        </style>
    </head>
    <body>

<h1>Boilerplate Removal with Uniplate</h1>

<p style="text-align:right;margin-bottom:25px;">
    by <a href="http://community.haskell.org/~ndm/">Neil Mitchell</a>
</p>

<p style="margin-left:10%;margin-right:10%;margin-bottom:25px;text-align:justify;">
    Generic transformations and queries are often referred to as boilerplate code - they remain relatively similar as the action performed by the code changes, and can often outnumber the actual intent of the code in terms of lines. While other generic traversal schemes have shown how powerful new features can be added to compilers, and how the type system can be manipulated into accepting these operations, the Uniplate library focuses on a conceptually simpler generic concept. A more complete document on Uniplate was published at the Haskell Workshop 2007, and is available from the <a href="http://community.haskell.org/~ndm/uniplate/">project website</a>, along with a video presentation, and the associated thesis chapter.
</p>
<p>
	Uniplate is a simple, concise and fast generics library. To expand on that sentance:
</p>
<ol>
	<li>A generics library is one which allows you to write functions that operate over a data structure without tying down all aspects of the data structure. In particular, when writing an operation, you don't need to give a case for each constructor, and you don't have to state which fields are recursive.</li>
	<li>Uniplate is the simplest generics library. Using Uniplate is suitable for all Haskell programmers.</li>
	<li>Uniplate is more concise than any other generics library.</li>
	<li>Uniplate is fast, not always the absolute fastest, but massively faster than many generics libraries.</li>
	<li>Uniplate is also less powerful than some other generics libraries, but if it does the job, you should use it.</li>
</ol>
<p>
    The Uniplate library can be installed with the standard sequence of cabal commands:
</p>
<pre>
cabal update
cabal install uniplate
</pre>
<p>
    This document proceeds as follows:
</p>
<ol>
    <li>Using Uniplate</li>
    <li>Using Biplate</li>
    <li>Making Uniplate Faster</li>
</ol>

<h3>Acknowledgements</h3>

<p>
    Thanks to Bj&ouml;rn Bringert for feedback on an earlier version of this document, Eric Mertens for various ideas and code snippets, and to Matt Naylor and Tom Shackell for helpful discussions.
</p>


<h2>Using Uniplate</h2>

<p>
    These examples revolve around a small arithmetic language, given here:

</p>
<pre>
import Data.Generics.Uniplate.Data

data Expr = Val Int
          | Add Expr Expr
          | Sub Expr Expr
          | Div Expr Expr
          | Mul Expr Expr
          | Neg Expr
          deriving (Show, Eq, Data, Typeable)
</pre>
<p>
    To start using Uniplate I recommend you import <tt>Data.Generics.Uniplate.Data</tt> and add <tt>deriving (Data, Typeable)</tt> to all types you wish to operate upon.
</p>

<h3>Checking for division by zero</h3>

<pre class="define">
universe :: Uniplate on => on -> [on]
</pre>
<p>
    If an expression is divided by zero, this causes a runtime error in our language. As part of the compiler, it's nice to give the user a warning message about this. This can be done with the following test:
</p>
<pre>
hasDivZero :: Expr -> Bool
hasDivZero x = not $ null [() | Div _ (Val 0) <- universe x]
</pre>
<p>
    Here the only Uniplate method being used is <tt>universe</tt>. Given a tree, <tt>universe</tt> returns all the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done above. For each division by zero found, any value is created in the list comprehension, and then this is checked to see if anything did match. Returning the count of divide by zero errors is trivial, simply use <tt>length</tt> instead of <tt>not $ null</tt>.  Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error.
</p>
<p>
    <i>Exercise:</i> Write a function to find all literals that occur in an expression, together with their count.
</p>

<h3>Basic optimisation</h3>

<pre class="define">
transform :: Uniplate on => (on -> on) -> on -> on
</pre>
<p>
    If we are negating a literal value, this computation can be performed in advance, so let's write a function to do this.
</p>
<pre>
optimise :: Expr -> Expr
optimise = transform f
    where f (Neg (Val i)) = Val (negate i)
          f x = x
</pre>
<p>
    Here the Uniplate method being used is <tt>transform</tt>. This applies the given function to all the children of an expression, before applying it to the parent. This can be thought of as bottom-up traversal of the data structure. The optimise code merely pattern matches on the negation of a literal, and replaces it with the literal.
</p>
<p>
    Now lets add another optimisation into the same pass, just before the <tt>f x = x</tt> line insert:
</p>
<pre>
    f (Add x y) | x == y = Mul x (Val 2)
</pre>
<p>
    This takes an addition where two terms are equal and changes it into a multiplication, causing the nested expression to be executed only once. This shows that normal Haskell applies, the Uniplate lets you write code as before.
</p>
<p>
    <i>Exercise:</i> Extend the optimisation to so that adding <tt>x</tt> to <tt>Mul x (Val 2)</tt> produces a multiplication by 3.
</p>


<h3>Depth of an expression</h3>

<pre class="define">
para :: Uniplate on => (on -> [res] -> res) -> on -> res
</pre>
<p>
    Now lets imagine that programmers in your language are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.
</p>
<pre>
depth :: Expr -> Int
depth = para (\_ cs -> 1 + maximum (0:cs))
</pre>
<p>
    This function performs a paramorphism (a bit like a fold) over the data structure. The function simply says that for each iteration, add one to the previous depth.  An evaluator for this expression language can also be modelled as a <tt>para</tt>, see inside the example directory to see an implementation.
</p>
<p>
    <i>Exercise:</i> Write a function that counts the maximum depth of addition only.
</p>

<h3>Renumbering literals</h3>

<pre class="define">
transformM :: (Monad m, Uniplate on) => (on -> m on) -> on -> m on
</pre>
<p>
    The literal values need to be replaced with a sequence of numbers, each unique. This is unlikely for an arithmetic expression, but consider bound variables in lambda calculus and it starts to become a bit more plausible:
</p>
<pre>
uniqueLits :: Expr -> Expr
uniqueLits x = evalState (transformM f x) [0..]
    where
        f (Val i) = do
            y:ys <- get
            put ys
            return (Val y)
        f x = return x
</pre>
<p>
    Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.
</p>
<p>
    <i>Exercise:</i> Allow each literal to occur only once, when a second occurance is detected, replace that literal with zero.
</p>

<h3>Generating mutants</h3>

<pre class="define">
contexts :: Uniplate on => on -> [(on, on -> on)]
</pre>
<p>
    The person who is inputting the expression thinks they made a mistake, they suspect they got one of the values wrong by plus or minus one. Generate all the expressions they might have written.
</p>
<pre>
mutate :: Expr -> [Expr]
mutate x = concat [[gen $ Val $ i-1, gen $ Val $ i+1]
                  | (Val i, gen) <- contexts x]
</pre>
<p>
   The <tt>transform</tt> function is useful for doing an operation to all nodes in a tree, but sometimes you only want to apply a transformation once. This is less common, but is sometimes required. The idea is that the context provides the information required to recreate the original expression, but with this node altered.
</p>
<p>
    <i>Exercise:</i> Replace one multiplication with addition, if there are no multiplications return the original expression.
</p>


<h3>Using Biplate</h3>

<p>
	All the operations defined in Uniplate have a corresponding Biplate instance. Typically the operations are just the same as Uniplate, with <tt>Bi</tt> on the end.
</p>
<pre class="define">
universeBi:: Biplate on with => on -> [with]
transformBi :: Biplate on with => (with -> with) -> on -> on
transformBiM :: (Monad m, Biplate on with) => (with -> m with) -> on -> m on
</pre>
<p>
	The biggest difference is for the functions <tt>childrenBi</tt> and <tt>descendBi</tt>. In these cases, if the starting type and the target type are the same, then the input value will be returned. For example:
</p>
<pre>
childrenBi (Add (Val 1) (Val 2)) == [Add (Val 1) (Val 2)]
children (Add (Val 1) (Val 2)) == [Val 1, Val 2]
</pre>

<h3>Making Uniplate Faster</h3>

<p>
	To make Uniplate faster import <tt>Data.Generics.Uniplate.Direct</tt>, and provide Uniplate instances by generating them with the <a href="http://community.haskell.org/~ndm/derive/">Derive tool</a>.
</p>


    </body>
</html>
