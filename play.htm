<html>
	<head>
		<title>Another Pattern for Almost Compositional Functions</title>
		<style type="text/css">
pre {
	border: 2px solid gray;
	padding: 1px;
	padding-left: 5px;
	margin-left: 10px;
	background-color: #eee;
}

pre.define {
	background-color: #ffb;
	border-color: #cc0;
}

body {
	font-family: sans-serif;
}

h1, h2, h3 {
	font-family: serif;
}

h1 {
	color: rgb(23,54,93);
	border-bottom: 1px solid rgb(79,129,189);
	padding-bottom: 2px;
	font-variant: small-caps;
}

h2 {
	color: rgb(54,95,145);
}

h3 {
	color: rgb(79,129,189);
}
		</style>
	</head>
	<body>

<h1>Another Pattern for Almost Compositional Functions</h1>

<p>
	In ICFP 2006 Bj&ouml;rn Bringert and Aarne Ranta introduced their paper, <a href="http://doi.acm.org/10.1145/1159803.1159834">"A Pattern for Almost Compositional Functions"</a>. In the year preceding this I had developed a different pattern, which I call the <i>Play</i> class. This pattern had been implemented in Yhc for the Core data type, and in Catch on several data types within the program. An undergrad pointed me at the above paper, and it was easy to see the similarities between the intentions. Since I feel my Play class offers some advantages (and some disadvantages, naturally) over the published approach, it seems natural to turn my pattern into a library and provide some documentation to cover it.
</p>
<p>
</p>
	This document proceeds as follows:
<p>
</p>
<ol>
	<li>The motivation and use cases for Play</li>
	<li>How to use the Play class</li>
	<li>Derivation of a Play instance for your own data type</li>
	<li>A comparison to the ICFP 2006 paper</li>
</ol>
<p>
	If you have already read the ICFP paper, I recommend skipping to the final section. All the examples used in this document can be found in the darcs repository.
</p>


<h2>Motivation and Use Cases</h2>

<p>
	The idea behind the Play class is that there exists a data structure, usually with a reasonable number of constructors, which is often transformed or analysed. The usual example of this would be a compiler, which has at its core an expression type. This can be seen as a form of generic programming.
</p>
<p>
	The Play class has the following goals:
</p>
<ul>
	<li>Adding a new constructor should require very few changes</li>
	<li>Traversals should have a minimal amount of boiler plate</li>
	<li>The obvious code should "just work"</li>
	<li>Haskell 98, where possible</li>
	<li>Writing new types of traverals is easy</li>
	<li>The default traversals cover most cases</li>
</ul>
<p>
	The ideas behind the Play class have been used extensively, in both the Yhc compiler and the Catch tool. In Catch there are 109 traversals using the Play class (as at Nov 2006), showing that the Play class gets extensive use.
</p>


<h2>Using Play</h2>

<p>
	These examples revolve around a small arithmetic language, given here:

</p>
<pre>
data Expr = Val Int
          | Add Expr Expr
          | Sub Expr Expr
          | Div Expr Expr
          | Mul Expr Expr
          | Neg Expr
          deriving (Show, Eq)
</pre>
<p>
	Assume that a Play class has already been written; so now <tt>instance Play Expr</tt> is available to us. Some examples are presented, in rough order of increasingly complexity. These examples are all available in the <tt>ExprExamples</tt> module.
</p>

<h3>Checking for division by zero</h3>

<pre class="define">
allOver :: Play on => on -> [on]
</pre>
<p>
	If an expression is divided by zero, this causes a runtime error in our language. As part of the compiler, it's nice to give the user a warning message about this. This can be done with the following test:
</p>
<pre>
hasDivZero :: Expr -> Bool
hasDivZero x = not $ null [() | Div _ (Val 0) <- allOver x]
</pre>
<p>
	Here the only Play method being used is <tt>allOver</tt>. Given a tree, <tt>allOver</tt> returns all the root of the tree, and all it's subtrees at all levels. This can be used to quickly flatten a tree structure into a list, for quick analysis via list comprehensions, as is done above. For each division by zero found, any value is created in the list comprehension, and then this is checked to see if anything did match. Returning the count of divide by zero errors is trivial, simply use <tt>length</tt> instead of <tt>not $ null</tt>.  Extra context could perhaps be given by printing some of the value that is being divided by zero, to help narrow down the error.
</p>
<p>
	<i>Exercise:</i> Write a function to find all literals that occur in an expression, together with their count.
</p>

<h3>Basic optimisation</h3>

<pre class="define">
mapUnder :: Play on => (on -> on) -> on -> on
</pre>
<p>
	If we are negating a literal value, this computation can be performed in advance, so let's write a function to do this.
</p>
<pre>
optimise :: Expr -> Expr
optimise = mapUnder $ \x -> case x of
    Neg (Val i) -> Val (negate i)
    x -> x
</pre>
<p>
	Here the Play method being used is <tt>mapUnder</tt>. This applies the given function to all the children of an expression, before applying it to the parent. This can be thought of as bottom-up traversal of the data structure. There is an equivalent <tt>mapOver</tt> defined, but generally <tt>mapUnder</tt> is used about 90% of the time. The optimise code merely pattern matches on the negation of a literal, and replaces it with the literal. Using mapUnder means that <tt>Neg (Neg (Val 1))</tt> is reduced to <tt>1</tt>, using mapOver would only perform the inner most reduction.

</p>
<p>
	Now lets add another optimisation into the same pass, just before the <tt>x -> x</tt> line insert:
</p>
<pre>
    Add x y | x == y -> Mul x (Val 2)
</pre>
<p>
	This takes an addition where two terms are equal and changes it into a multiplication, causing the nested expression to be executed only once. This shows that normal Haskell applies, the Play lets you write code as before.
</p>
<p>
	<i>Exercise:</i> Extend the optimisation to so that adding <tt>x</tt> to <tt>Mul x (Val 2)</tt> produces a multiplication by 3.
</p>


<h3>Elimination of Negation</h3>

<pre class="define">
mapOver :: Play on => (on -> on) -> on -> on
</pre>
<p>
	It is possible to eliminate negation entirely, and perhaps this would be a useful computation to perform:
<p>
<pre>
noNegate :: Expr -> Expr
noNegate = mapOver $ \x -> case x of
    Neg (Val i) -> Val (negate i)
    Neg (Neg x) -> x
    Neg (Sub a b) -> Sub b a
    Neg (Add a b) -> Add (Neg a) (Neg b)
    Neg (Div a b) -> Div (Neg a) b
    Neg (Mul a b) -> Mul (Neg a) b
    x -> x
</pre>
<p>
	This is an example where a bottom up traversal would not work, as information is being pushed from the top downwards. Note how each line states a mathematical property, which can be proved in isolation, and that the Play class handles the traverals.
</p>
<p>
	<i>Exercise:</i> Write a similar transformation to eliminate subtraction. These two transformations can be composed, to give a reduced expression language. Can any other expressions be eliminated?
</p>


<h3>Depth of an expression</h3>

<pre class="define">
fold :: Play on => ([res] -> tmp) -> (on -> tmp -> res) -> on -> res
</pre>
<p>
	Now lets imagine that programmers in your language are paid by the depth of expression they produce, so lets write a function that computes the maximum depth of an expression.
</p>
<pre>
depth :: Expr -> Int
depth = fold (foldr max 0) $ const (+1)
</pre>
<p>
	This function performs a fold over the data structure. The <tt>foldr max</tt> is being used as maximum, with a starting value of <tt>0</tt>. The next bit simply says that for each iteration, add one to the previous depth.  An evaluator for this expression language can also be modelled as a <tt>fold</tt>, see inside the example directory to see an implementation.
</p>
<p>
	Each <tt>fold</tt> collects all the values from the children of an expression, combines them using the first function, then generates a new value based on the expression. Often the combining function will simply be <tt>id</tt>.
<p>
<p>
	<i>Exercise:</i> Write a function that counts the maximum depth of addition only.
</p>

<h3>Renumbering literals</h3>

<pre class="define">
mapUnderM :: (Monad m, Play on) => (on -> m on) -> on -> m on
</pre>
<p>
	The literal values need to be replaced with a sequence of numbers, each unique. This is unlikely for an arithmetic expression, but consider bound variables in lambda calculus and it starts to become a bit more plausible:
</p>
<pre>
uniqueLits :: Expr -> Expr
uniqueLits x = evalState (mapUnderM f x) [0..]
    where
        f (Val i) = do
            y:ys <- get
            put ys
            return (Val y)
        f x = return x
</pre>
<p>
	Here a monadic computation is required, the program needs to keep track of what the next item in the list to use is, and replace the current item. By using the state monad, this can be done easily.
</p>
<p>
	<i>Exercise:</i> Allow each literal to occur only once, when a second occurance is detected, replace that literal with zero.
</p>

<h3>Reverse notation</h3>

<pre class="define">
replaceChildren :: on -> ([on], [on] -> on)
</pre>
<p>
	In general, <tt>allOver</tt> and <tt>mapUnder</tt> are used most of the time, and <tt>fold</tt> is used occasionally. The Play class is built upon the operation <tt>replaceChildren</tt>, which takes an expression, and returns a pair with the children of that expression, and a function to generate that expression with a new set of children in place. This operation can be directly exploited if required, although should be handled with caution.
</p>
<p>
	Let us make a function that reverses the order of all the inputs, say if the user is working in Right-to-Left mode on their computer:
</p>
<pre>
reverseExpr :: Expr -> Expr
reverseExpr = mapUnder f
    where
        f x = generate $ reverse collect
            where (collect,generate) = replaceChildren x
</pre>
<p>
	This expression does a standard <tt>mapUnder</tt>, but at each iteration calls <tt>replaceChildren</tt>, then reverses the children set before regenerating the original expression. This shows the underlying mechanism on which the library is based, and isn't recommended for average users.
</p>

	</body>
</html>
